<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[name]]></title>
    <url>%2F2017%2F04%2F06%2F%EF%BC%88url%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E6%A0%87%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Earth开发原理-阴影体实现要素贴地1.关于阴影实现方法概述​ Shadow map: 阴影的实现技术，我以前实现过比较基础的shadow map，就是利用从光源出发得到的深度图，然后每一个像素去比较当前深度值与深度图中的得到的深度值，深度图其实保存的应该是光源到遮光板之间的距离，而与它比较的是像素到光源的距离，如果小于，则说明处于阴影之中。还有一些细节的改进，比如阴影交叉如何处理（与深度图的分辨率有关，如果多个像素用同一个比较，就会出现这种情况），还有锯齿如何处理等等。 具体可以看这篇教程：Shadow map。 ​ Shadow volume: 上面这种方法会有两个问题：1.如果光源动态变化，则每一次shadow map都要更新，这样开销会很大；2.上述出现的交叉阴影和锯齿问题，都没有一种很好的方法完美解决。因此Franklin C. Crow在1977年 提出了一种新的方法：Shadow volume。不过这种方法好像对于多源多的情况下，也并无优势。所以现在主流的依然是shadow map方法，可以结合deferred lighting技术。不过因为今天的主题是要用到阴影体这种方法，所以下面线详细介绍一下这种方法。 ##2.Shadow volume实现方法 ​ shadow volume主要用到的原理是模板测试和深度测试，通过这两个测试，把阴影部分的stencil buffer计算出来，然后render这部分就可得到阴影。 ​ 第一步：构建阴影体。对mesh每一条边沿着光源方向进行拉伸，顶点部分除了原始的n个顶点(x,y,z,1)外，拉伸后的顶点同样也有n个，拉伸的长度应是无限远，但我们只有将其顶点形式设置为（x,y,z,0），在shader里面转换后自然就是无穷远处。面主要包括顶面、底面和侧面，底面三角形索引结构其实和顶面是一样的，侧面就是每一个quad由两个三角形组成，这样就可以得到阴影体的vertex buffer。 ​ 第二步：Render pass。 ​ pass1：打开depth test，按正常方式渲染整个场景，得到depth map。 ​ pass2：打开stencil test，关掉z writing和color buffer writing，渲染shadow volumes；设置stencil test always pass，对于front faces，若z test pass，则stencil value +1，若z test fail，则不更新stencil value；对于back faces，若z test pass，则stencil value -1。 ​ pass3：pass2完成之后，stencil buffer中value不为0的像素就处于阴影区域，据此绘制阴影效果即可。 12345678910111213141516//pass1RenderVolumetoDepth();//pass 2glDepthMask(GL_FALSE);glEnable(GL_DEPTH_CLAMP);glDisable(GL_CULL_FACE);glStencilFunc(GL_ALWAYS, 0, 0xff); glStencilOpSeparate(GL_BACK, GL_KEEP, GL_INCR_WRAP, GL_KEEP);glStencilOpSeparate(GL_FRONT, GL_KEEP, GL_DECR_WRAP, GL_KEEP);RenderVolume();//pass 3glStencilFunc(GL_EQUAL, 0x0, 0xFF); glStencilOpSeparate(GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP);RenderVolume();glDisable(GL_STENCIL_TEST);...... ​ 这样就可以实现一个简单的阴影效果了，其中核心就是利用模板测试标记出阴影部分，当然还有一些细节，比如多光源的时候需要遍历每一个光源，想根深一步了解可以看《GPU Gems》Chapter 9. Efficient Shadow Volume Rendering. 3.利用阴影体实现贴地效果​ 前面简单的介绍了一下shadow volume的原理，下面要进入正题，要素贴地。这算是三维球中一个很基本的功能，因为这会涉及要标会，量测，矢量要素加载等等，所以这个问题也必须解决，才能有后续这些相关功能的实现。一开始对这个没什么概念，想了很多方法，第一反应到的就是纹理。在有DEM数据的情况下，面对高低起伏的地形，如何将要素随着地形起伏，感觉只有将其作为一张纹理贴地和瓦片数据一样贴到地形网格上，才能完美贴地，好像osgearth就是这样做的，所以就去研究投影纹理技术，投影纹理就不展开讲了，就类似虚拟一个投影仪，然后将纹理投影到物体表面，]]></content>
      <categories>
        <category>Earth开发原理</category>
      </categories>
      <tags>
        <tag>三维GIS</tag>
        <tag>图形算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[name]]></title>
    <url>%2F2016%2F04%2F06%2F%EF%BC%88url%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E6%A0%87%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hello world，Test！！]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>开始</tag>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
