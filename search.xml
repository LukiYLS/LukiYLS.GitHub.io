<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[我的音视频技术路线]]></title>
      <url>/2020/03/30/%EF%BC%88url%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E6%A0%87%E9%A2%98%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>​    抖音/快手等短视频APP的风靡，让音视频成为当下最火热的技术，越来越多的人想要进入到这个领域，我自己也是从图形方向刚刚踏入这领域不久，音视频方向所包含的技术栈非常复杂，我自己也在一点一点慢慢钻研，这里面每一个方向都值得深入研究，而且随着5G时代的到来，音视频方向的应用会更加广泛，所以希望自己能掌握更多的关于音视频方向的技能，未来可以探索更多的音视频玩法。然后这篇博客主要是想梳理一下我自己关于音视频这个方向的学习路线，分享出来的同时也能鼓励自己朝着这个方向继续深耕下去。</p>
<p>​    关于音视频方向的基础技能分支，先来看一张图（图片来自网上）</p>
<p><img src="https://i.loli.net/2020/03/30/XOIjb1L9vAak2Zs.jpg" alt="basic.jpg"></p>
<p>采集：音视频数据来源，比如Android Camera数据采集</p>
<p>渲染：将采集得到的数据展示到Surface上，并添加一些图形效果</p>
<p>处理：对源数据的加工，比如添加滤镜、特效，还有多视频剪辑、变速、转场等等</p>
<p>编解码：对音视频数据进行压缩封装，减少数据量，方便传输</p>
<p>传输：对采集加工完成的数据传输至客户端，比如直播推流、拉流</p>
<a id="more"></a>
<h3 id="1-关于音视频数据采集-Android"><a href="#1-关于音视频数据采集-Android" class="headerlink" title="1. 关于音视频数据采集(Android)"></a>1. 关于音视频数据采集(Android)</h3><p>​    因为自己主要是对Android Camera比较熟悉，所以我主要梳理一下这方面的知识点，我会从最基础的Android Camera API的接口以及基本流程开始梳理，后面进阶部分主要是结合Camera HAL高通架构进一步详细梳理底层的Camera原理，最后是我对于Camera专业视频方向的一些探索。</p>
<h4 id="1-1-Android-Camera-API"><a href="#1-1-Android-Camera-API" class="headerlink" title="1.1 Android Camera API"></a>1.1 Android Camera API</h4><p>​      Android 5.0之后Camera接口升级成API2，因为Camera API 1接口过于简单，根本体现不出硬件能力，用户能控制的不多，比如拿不到RAW数据，控制不了相机参数的下发等等，如下代码看下他内部的基本接口</p>
<p>​    Camera API 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            mCamera = Camera.open(mCurrentCamera);</span><br><span class="line">            Camera.Parameters params = mCamera.getParameters();</span><br><span class="line">            List&lt;Camera.Size&gt; previewSizes = params.getSupportedPreviewSizes();</span><br><span class="line"></span><br><span class="line">            Camera.Size preViewSize = previewSizes.get(previewSizes.size() &gt; <span class="number">4</span> ? previewSizes.size() - <span class="number">4</span> : <span class="number">0</span>);</span><br><span class="line">            params.setPreviewSize(preViewSize.width, preViewSize.height);</span><br><span class="line">            mPreviewHeight = preViewSize.height;</span><br><span class="line">            mPreviewWidth = preViewSize.width;</span><br><span class="line">            Log.e(TAG, <span class="string">"preViewSize-&gt;width: "</span> + preViewSize.width + <span class="string">", preViewSize-&gt;height: "</span> + preViewSize.height);</span><br><span class="line"></span><br><span class="line">            params.setPictureFormat(ImageFormat.JPEG);</span><br><span class="line">            params.setJpegQuality(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">//是否开启闪光</span></span><br><span class="line">            List&lt;String&gt; flashModes = params.getSupportedFlashModes();</span><br><span class="line">            <span class="keyword">if</span> (flashModes != <span class="keyword">null</span> &amp;&amp; flashModes.contains(Camera.Parameters.FLASH_MODE_OFF)) &#123;</span><br><span class="line">                params.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCamera.setPreviewCallback(<span class="keyword">this</span>);</span><br><span class="line">            mCamera.setDisplayOrientation(PORTRAIT_MODE);</span><br><span class="line">            mCamera.setParameters(params);</span><br><span class="line">            <span class="keyword">if</span>(!Consts.SHOW_CAMERA) &#123;</span><br><span class="line">                LogUtils.log_main_step(<span class="string">"相机开始preview"</span>);</span><br><span class="line">                mCamera.startPreview();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LogUtils.logd(TAG, <span class="string">"camera init finish....."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LogUtils.loge(TAG, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>然后在CameraPreview callback里面就可以处理相机数据了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">        Camera.CameraInfo mCameraInfo = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line">        <span class="comment">//如果使用前置摄像头，请注意显示的图像与帧图像左右对称，需处理坐标</span></span><br><span class="line">        <span class="keyword">boolean</span> frontCamera = (mCurrentCamera == Camera.CameraInfo.CAMERA_FACING_FRONT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取重力传感器返回的方向</span></span><br><span class="line">        <span class="keyword">int</span> dir = getDirection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rotate = (dir ^ <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//Log.e("stRotateCamera  ", (dir ^ 1) + " rotate result");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在使用后置摄像头，且传感器方向为0或2时，后置摄像头与前置orentation相反</span></span><br><span class="line">        <span class="keyword">if</span> (!frontCamera &amp;&amp; dir == <span class="number">0</span>) &#123;</span><br><span class="line">            dir = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!frontCamera &amp;&amp; dir == <span class="number">2</span>) &#123;</span><br><span class="line">            dir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dir = (dir ^ <span class="number">2</span>);</span><br><span class="line">      	<span class="comment">//.....</span></span><br><span class="line">      	process(data)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://graphics.stanford.edu/projects/camera-2.0/" target="_blank" rel="noopener">    关于Camera2的介绍</a></p>
<blockquote>
<p>Camera 2.0: New computing platforms for computational photography</p>
</blockquote>
<p>​    Camera API2对比API 1改动非常大，主要配合HAL3进行使用，功能和接口都更加齐全，同时使用起来也会更加复杂，但如果熟悉之后，也能拍摄出更加丰富的效果。下图关于Camera API 2的几个使用场景</p>
<p><img src="https://i.loli.net/2020/03/30/YwbtVpLrKUPCX97.png" alt="camera_api2.png"></p>
<p>​    然后结合具体代码讲几个Camera2的主要接口</p>
<p><strong>1.CameraManager</strong></p>
<p>关于硬件能力的统一封装接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CameraManager cameraManager = (CameraManager)mContext.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line"><span class="comment">//可以拿到所以的相机列表，比如Wide，Tele，Macro，Tele2x，Tele4x等等</span></span><br><span class="line">String[] cameraIdList = cameraManager.getCameraIdList();</span><br><span class="line"><span class="comment">//根据Camera ID拿到对应设备支持的能力</span></span><br><span class="line">CameraCharacteristics cameraCharacteristics =</span><br><span class="line">  cameraManager.getCameraCharacteristics(cameraIdStr);</span><br><span class="line"><span class="comment">//比如用这个去判断支持的最小Focus distance</span></span><br><span class="line">Float focusDistance = mCharacteristics.get(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE);</span><br></pre></td></tr></table></figure>
<p>​    现如今机型的摄像头的数量越来越多，组合也越来越丰富，不同的Camera负责不同的能力，比如我们需要更大的拍摄范围会选择Ultra Wide，比如小米一亿像素的Wide，还有Macro等等。</p>
<p><strong>2.CaptureDevice</strong></p>
<p>我们可以在OpenCamera Callback拿到CameraDevice</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">String cameraIdStr = String.valueOf(mCameraId);</span><br><span class="line">            cameraManager.openCamera(cameraIdStr, mCameraStateCallback, mMainHandler);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> CameraDevice.StateCallback mCameraStateCallback = <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(@NonNull CameraDevice camera)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SnapCamera.<span class="keyword">this</span>) &#123;</span><br><span class="line">                mCameraDevice = camera;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mStatusListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mStatusListener.onCameraOpened();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(@NonNull CameraDevice camera)</span> </span>&#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"onDisconnected"</span>);</span><br><span class="line">            <span class="comment">// fail-safe: make sure resources get released</span></span><br><span class="line">            release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull CameraDevice camera, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"onError: "</span> + error);</span><br><span class="line">            <span class="comment">// fail-safe: make sure resources get released</span></span><br><span class="line">            release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>3.<strong>CaptureRequest</strong></p>
<p>​       通过CameraDevice可以创建CaptureRequest，类型主要有以下几种，1-6分布用于预览、拍照、录制、录制中拍照、ZSL、手动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEMPLATE_MANUAL = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEMPLATE_PREVIEW = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEMPLATE_RECORD = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEMPLATE_STILL_CAPTURE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEMPLATE_VIDEO_SNAPSHOT = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEMPLATE_ZERO_SHUTTER_LAG = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//创建的代码</span></span><br><span class="line">mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是更加专业一点的用法，可以不看，就是拿到RequestBuilder之后我们可以去下发各种TAG，如下设置AE/AWB锁</span></span><br><span class="line">CaptureRequestBuilder.applyAELock(request, mConfigs.isAELocked());</span><br><span class="line">CaptureRequestBuilder.applyAWBLock(request, mConfigs.isAWBLocked());</span><br></pre></td></tr></table></figure>
<p>4.<strong>Surface</strong></p>
<p>Surface主要是用来接相机返回的数据，可以支持不同的数据类型和分辨率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SurfaceTexture的方式，用于预览</span></span><br><span class="line">mSurfaceTexture = <span class="keyword">new</span> SurfaceTexture(<span class="keyword">false</span>);</span><br><span class="line">mSurfaceTexture.setDefaultBufferSize(optimalSize.width, optimalSize.height);</span><br><span class="line">mPreviewSurface = <span class="keyword">new</span> Surface(mSurfaceTexture);</span><br><span class="line"><span class="comment">//ImageReader 的方式, Format可以是YUV、RAW，DEPTH等</span></span><br><span class="line">mPhotoImageReader = ImageReader.newInstance(size.getWidth(), size.getHeight(),</span><br><span class="line">                ImageFormat.JPEG, <span class="comment">/* maxImages */</span> <span class="number">2</span>);</span><br><span class="line">mPhotoImageReader.setOnImageAvailableListener(mPhotoAvailableListener, mCameraHandler);</span><br><span class="line"><span class="comment">//创建session</span></span><br><span class="line">List&lt;Surface&gt; surfaces = Arrays.asList(mPreviewSurface, mPhotoImageReader.getSurface());</span><br><span class="line">mCameraDevice.createCaptureSession(surfaces, mSessionCallback, mCameraHandler);</span><br></pre></td></tr></table></figure>
<p>5.<strong>CaptureSession</strong></p>
<p>通过上面的CameraDevice创建Session，在Callback里面拿到Session</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mCameraDevice.createCaptureSession(surfaces, mSessionCallback, mCameraHandler);</span><br><span class="line"><span class="keyword">private</span> CameraCaptureSession.StateCallback</span><br><span class="line">            mSessionCallback = <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(@NonNull CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SnapCamera.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCameraDevice == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"onConfigured: CameraDevice was already closed."</span>);</span><br><span class="line">                    session.close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mCaptureSession = session;</span><br><span class="line">            &#125;</span><br><span class="line">            startPreview();</span><br><span class="line">            capture();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(@NonNull CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"sessionCb: onConfigureFailed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>​    后面所有的采集工作都是基于Session，关于Session机制最早是诺基亚提出来的，后面苹果的IOS也采取Session作为相机拍照，录制的会话单元。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*发起请求，后续相机开始往surface输出数据，这个可以在onConfigured里面调用，如上面的代码       		    startPreview();</span></span><br><span class="line"><span class="comment">capture();*/</span></span><br><span class="line">mCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(),</span><br><span class="line">                    mCaptureCallback, mCameraHandler);</span><br><span class="line">mCaptureSession.capture(requestBuilder.build(), mCaptureCallback, mCameraHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是针对120/240/960Fps recording</span></span><br><span class="line">mCaptureSession.setRepeatingBurst(requestList, mCaptureCallback, mCameraHandler);</span><br><span class="line">mCaptureSession.captureBurst(requestList, listener, handler);</span><br></pre></td></tr></table></figure>
<p>然后还可以通过Session控制结束动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mCaptureSession.abortCaptures();</span><br><span class="line">mCaptureSession.stopRepeating();</span><br></pre></td></tr></table></figure>
<p>​    对象更加专业一点的系统相机而言，在setRepeatingRequest之前可以还需要做很多工作，比如拍照要等Focus finish，还需要Apply一些列参数，比如FocusMode, Zoom, AE/F Lock, Video FPS…..</p>
<p>总结：上面只是一个大概流程，至于每个流程你需要去控制什么可能就会更加复杂，但其实对于第三方APP，需要控制的不多，基本就是OpenCamera -&gt; 配置Surface -&gt; 创建Session -&gt; 设置参数 -&gt; RepeatingRequest -&gt;ImageReader或者GLSurafce回调接数据做后续处理。可能有些更加专业一点的相机应用，可能会涉及的一些专业参数的下发，比如IOS, FocusDistance, Shutter Time, EV….</p>
<h4 id="1-2-Camera-HAL"><a href="#1-2-Camera-HAL" class="headerlink" title="1.2 Camera HAL"></a>1.2 Camera HAL</h4><blockquote>
<p>Android Camera硬件抽象层（HAL，Hardware Abstraction Layer）主要用于把底层camera drive与硬件和位于android.hardware中的framework APIs连接起来。Camera子系统主要包含了camera pipeline components 的各种实现，而camera HAL提供了这些组件的使用接口</p>
</blockquote>
<p>官网的系统架构图：</p>
<p><img src="https://i.loli.net/2020/03/30/xBLf8olEGuO3FAq.png" alt="camera_hal.png"></p>
<p>​    做相机开发除了第一部分讲到的APP层面的相机控制，然后就是HAL层的开发了，HAL层由芯片厂商定制(比如高通等),手机厂商可以再其上增加一些内容。Camera HAL 经历1-3的版本迭代，不同的硬件支持的Camera2程度不一样，主要有以下等级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一个等级啥意思自己搜吧</span></span><br><span class="line">INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY</span><br><span class="line">INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED</span><br><span class="line">INFO_SUPPORTED_HARDWARE_LEVEL_FULL</span><br><span class="line">INFO_SUPPORTED_HARDWARE_LEVEL_3</span><br><span class="line">INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL</span><br></pre></td></tr></table></figure>
<p> 想了一下这一块比较复杂，我自己也不是非常的清楚，而且好像第三方APP一般不会涉及，后面有机会单独整理吧(挖坑1)</p>
<h4 id="1-3-CameraX"><a href="#1-3-CameraX" class="headerlink" title="1.3 CameraX"></a>1.3 CameraX</h4><p>​    如上看到的Camera API2非常复杂，为了简化流程，Google推出CameraX，借助 CameraX，开发者只需两行代码就能利用与预安装的相机应用相同的相机体验和功能。 CameraX Extensions 是可选插件，通过该插件，您可以在支持的设备上向自己的应用中添加人像、HDR、夜间模式和美颜等效果。如下预览和拍照的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预览</span></span><br><span class="line">PreviewConfig config = <span class="keyword">new</span> PreviewConfig.Builder().build();</span><br><span class="line">Preview preview = <span class="keyword">new</span> Preview(config);</span><br><span class="line"></span><br><span class="line"> preview.setOnPreviewOutputUpdateListener(</span><br><span class="line">     <span class="keyword">new</span> Preview.OnPreviewOutputUpdateListener() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpdated</span><span class="params">(Preview.PreviewOutput previewOutput)</span> </span>&#123;</span><br><span class="line">             <span class="comment">// Your code here. For example, use previewOutput.getSurfaceTexture()</span></span><br><span class="line">             <span class="comment">// and post to a GL renderer.</span></span><br><span class="line">         &#125;;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> CameraX.bindToLifecycle((LifecycleOwner) <span class="keyword">this</span>, preview);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拍照</span></span><br><span class="line">ImageCaptureConfig config =</span><br><span class="line"><span class="keyword">new</span> ImageCaptureConfig.Builder()</span><br><span class="line">        .setTargetRotation(getWindowManager().getDefaultDisplay().getRotation())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">ImagesCapture imageCapture = <span class="keyword">new</span> ImageCapture(config);</span><br><span class="line">CameraX.bindToLifecycle((LifecycleOwner) <span class="keyword">this</span>, imageCapture, imageAnalysis, preview);</span><br><span class="line"></span><br><span class="line">ImageCapture.Metadata metadata = <span class="keyword">new</span> ImageCapture.Metadata();</span><br><span class="line">        metadata.isReversedHorizontal = mCameraLensFacing == LensFacing.FRONT;</span><br><span class="line">imageCapture .takePicture(saveLocation, metadata, executor, OnImageSavedListener);</span><br></pre></td></tr></table></figure>
<h4 id="1-4-Camera专业视频-进阶"><a href="#1-4-Camera专业视频-进阶" class="headerlink" title="1.4 Camera专业视频(进阶)"></a>1.4 Camera专业视频(进阶)</h4><p>​    现如今手机相机功能越来越强大，现在已经基本可以取代卡片机，手机相机已经作为手机厂商最重要的一个卖点，尤其是DXO刷榜的行为，之后让厂商投入更多的研发相机上面，在可以预见的未来，手机相机发展势必会更加激进，后面进一步取代部分单反也是有可能的，所以相机未来应该更多的体现起作为生产力工具的一部分，尤其是现在视频作为人们记录生活的方式，越来越得到普及。</p>
<p>​    如果说到视频和相机，我的想法是如何去拍摄更加专业的视频，借助手机相机强大的功能，能否让一部分专业人士用他作为生产力工具，部分取代非常不便携的单反设备，比如借助Camera2参数调节功能去实现长曝光、延时、流光快门等效果。</p>
<p>​    相机更加专业的方向，主要体现手机厂商的系统相机，尤其是Android端，很多硬件能力只能由手机厂商自己控制，比如系统相机里面的专业模式，还有就是类似大疆这种，也是自己做相机硬件，然后能够结合硬件能力，去实现一些更加专业的拍摄效果。目前软件这块做的比较专业的就是<a href="https://www.filmicpro.com/" target="_blank" rel="noopener">Fimic Pro</a>。</p>
<p><img src="https://i.loli.net/2020/03/30/QrSPgaK8Y1N6VUL.png" alt="filmic.png"></p>
<p>​    </p>
<p>​    支持各种调参：ISO ，Exposure time，WB，EV，Focus distance</p>
<p>​    支持平滑变焦，光焦分离</p>
<p>​    支持曲线调整：亮度、饱和度、阴影、Gamma曲线等</p>
<p>​    支持LOG格式，还有专业的音频采集</p>
<p>​    有非常多的辅助信息，比如峰值对焦、曝光反馈、RGB直方图信息等</p>
<p>​    音视频各种格式自定义：画幅比例、FPS、分辨率、音频采样率、编码格式等等</p>
<p>​    </p>
<p>真的是一个非常强大的生产力工具</p>
<h3 id="2-关于图形渲染"><a href="#2-关于图形渲染" class="headerlink" title="2. 关于图形渲染"></a>2. 关于图形渲染</h3><p>​    音视频第二部分肯定是图形渲染方向啦，因为之前一直有做图形渲染方面的工作，也写过自己的渲染引擎，链接如下</p>
<p>​    <a href="https://github.com/LukiYLS/SimpleRenderer" target="_blank" rel="noopener">https://github.com/LukiYLS/SimpleRenderer</a></p>
<p>以及关于这个引擎的介绍</p>
<p>​    <a href="http://yanglusheng.com/" target="_blank" rel="noopener">http://yanglusheng.com/</a></p>
<p>​    所以可以大概分享一下自己的学习过程，以及关于Android GLES相关总结</p>
<h4 id="2-1-图形学基础"><a href="#2-1-图形学基础" class="headerlink" title="2.1 图形学基础"></a>2.1 图形学基础</h4><p>​    我觉图形方面基础的应该需要掌握如下：</p>
<p>1.<strong>整个图形矩阵变换过程</strong></p>
<p>World Matrix：将场景中所有对象统一到一个坐标系下</p>
<p>ViewMatrix：World Matrix 变换的相机坐标系，根据相机的三个参数生成</p>
<p>ProjectionMatrix：3D世界投影的2D平面</p>
<p>NDC：转换到[-1 1]</p>
<p>Screen Matrix：转换的屏幕坐标系</p>
<p>这部分想要理解就要自己用笔手推一遍，非常管用</p>
<p>2.<strong>OpenGL API</strong></p>
<p>熟悉API，比如纹理贴图方式，绘制点线面，VAO/VBO创建等等</p>
<p>3.<strong>光照</strong></p>
<p>首先需要理解传统的Phong光照，然后要看PBR，理解BRDF模型和公式推导</p>
<p>还有就是Shadow这快，理解shadowmap的原理，不同的光照怎样生成深度图，然后shadow acne，处理边缘锯齿等很多细节，还有阴影体这块</p>
<p>4.<strong>模版测试/深度测试</strong></p>
<p>深度测试实现遮挡</p>
<p>模版测试也是非常有用，比如我有篇博客里面讲到的 阴影体结合模版测试实现矢量紧贴地形的效果</p>
<p>5.<strong>地形</strong></p>
<p>怎用利用perlin noise生成地形顶点数据</p>
<p>LOD的地形：规则四叉树划分(Google Earth地形)，以及不规则的CLOD(自适应三角网)</p>
<p>6.<strong>粒子系统</strong></p>
<p>主要就是怎么控制粒子发射器，粒子加速的，粒子运动轨迹等等</p>
<p>7.<strong>场景管理</strong></p>
<p>如何利用四叉树、八叉树管理场景节点，做视锥体裁剪</p>
<p>……..</p>
<p>//之前写的earth平台，包括八叉树管理全球数据的想法</p>
<p><img src="https://i.loli.net/2020/03/30/4tjRNxuId9657Ma.png" alt="global_earth.png"></p>
<p><strong>总结：</strong></p>
<p>学习图形学最好的方式就是造轮子造轮子造轮子，自己写引擎，自己写软光栅器</p>
<p>学习资料分享：</p>
<p><a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/</a></p>
<p><a href="https://www.scratchapixel.com/" target="_blank" rel="noopener">https://www.scratchapixel.com/</a></p>
<p>阅读源码：OGRE/OSG/THREEJS</p>
<p>工具: unity3d processing</p>
<h4 id="2-2-OpenGL-GLES"><a href="#2-2-OpenGL-GLES" class="headerlink" title="2.2 OpenGL/GLES"></a>2.2 OpenGL/GLES</h4><p><strong>1.EGL环境创建</strong></p>
<p>   eglGetDisplay //获取display信息</p>
<p>   eglChooseConfig //设置RGBA bit depth</p>
<p>   eglCreatePbufferSurface // 创建离屏surface, 也可以eglCreateWindowSurface</p>
<p>   eglCreateContext //创建上下文</p>
<p><strong>2.GL多线程</strong></p>
<ul>
<li><p>SharedContext多线程</p>
<p>这个网上也有很多资料，eglCreateContext 的时候传入其它线程的Context，既可以共享一些GPU Buffer，比如：MediaCodec录制的用的Surface，和预览去sharedContext</p>
</li>
<li><p>Render pass如何做同步glFenceSync</p>
<p>如果用glFinish可能会在某个点等的时间很长，可以用glFenceSync做同步，非常不错</p>
</li>
</ul>
<p><strong>3.渲染优化</strong></p>
<p>​        帧率如何优化，涉及到很多方面，这方面游戏引擎有很多技巧，比如提前视锥体裁剪，遮挡剔除等等，我这里只是简单讲一下在不涉及到大场景的优化有哪些</p>
<p>个人关于效率优化的总结：</p>
<p>​    尽量在渲染之前先做视锥体裁剪工作，减少不必要的IO</p>
<p>​    尽量少使用一些同步阻塞操作，比如glReadPixel、glFinish、glTeximage2D等</p>
<p>​    Shader里面少使用if/for这种操作</p>
<p>​    必要时做下采样</p>
<p>​    利用好内存对齐，会有意想不到的效率提升</p>
<p>​    渲染之前做好一些列准备工作，比如编译Shader</p>
<h4 id="2-3-音视频渲染引擎-扒抖音"><a href="#2-3-音视频渲染引擎-扒抖音" class="headerlink" title="2.3 音视频渲染引擎(扒抖音)"></a>2.3 音视频渲染引擎(扒抖音)</h4><p>​    现在短视频应用关于特效部分底层都有会有一套渲染引擎，不管的抖音还是快手，你把抖音的的APP package pull出来就能看到，里面是同lua脚本去调用底层的渲染引擎，lua脚本负责下发一些参数，主要是AI的一些识别结果以及用户的交互事件。</p>
<p>​    虽然没有游戏引擎那么强大，但基本模块应该都会包含模型、资源管理、相机控制、裁剪、渲染等等，毕竟写这套引擎的基本都是以前搞游戏的那拨人，算是降维来写音视频渲染引擎。</p>
<p>​    下面通过拆解抖音内部的资源文件，探究内部关于音视频渲染引擎的模块组成，对比短视频引擎和游戏引擎的区别。</p>
<p> 一起来看看抖音最近很火的一个游戏：潜水艇，通过移动鼻子控制潜水艇</p>
<p><img src="https://i.loli.net/2020/03/30/lXpri2536NO7cmI.png" alt="tiktok_demo.png" style="zoom:50%;"></p>
<p>如下是download 的资源包</p>
<p><img src="https://i.loli.net/2020/03/30/a8FhiQmOTnA5Lzk.png" alt="tiktok_effect1.png"></p>
<p>​    这里面的核心控制逻辑就是那个lua基本，里面会负责把人脸关键点信息传给底层引擎，实时更新潜水艇的位置，脚本实现了两个碰撞检测函数，用于潜水艇和柱子之间做碰撞检测。Collision玩过游戏引擎的都很熟悉，有些游戏引擎Collision detect做的不好的会出现穿模的现象。</p>
<p>​    rectCollision: 潜水艇中心坐标和柱子底部坐标之间的距离，与潜水艇半径比较，小于0.9*R，就是碰撞了</p>
<p>​    circleCollision:  两个圆心坐标之间的距离和他们各自半径之和比较，小于半径和，就是碰撞了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">local intpx = <span class="number">220</span>      --柱子左右间隔</span><br><span class="line">local intpy = <span class="number">550</span>      --柱子中间缝隙宽度</span><br><span class="line">local range_y = &#123;<span class="number">0.3</span>, <span class="number">0.7</span>&#125;      --柱子缝隙中央随机范围，&#123;<span class="number">0.3</span>,<span class="number">0.7</span>&#125;代表缝隙可能在屏幕高度<span class="number">30</span>%<span class="number">-70</span>%的位置随机出现</span><br><span class="line">local sp = &#123;<span class="number">0.5</span>,<span class="number">1.0</span>&#125;         --速度初始和最终速度，&#123;<span class="number">0.5</span>,<span class="number">1.0</span>&#125;代表初始速度为<span class="number">1</span>秒走过<span class="number">0.5</span>个屏幕，最终速度为<span class="number">1</span>秒走过<span class="number">1</span>个屏幕</span><br><span class="line">local ptime = <span class="number">3</span>           --准备时间<span class="number">3</span>s</span><br><span class="line">local range_s = &#123;<span class="number">5</span>,<span class="number">10</span>&#125;  --分数分段，&#123;<span class="number">5</span>,<span class="number">10</span>&#125;代表<span class="number">0</span><span class="number">-5</span>第一段，<span class="number">6</span><span class="number">-10</span>第二段，<span class="number">10</span>以上第三段；<span class="number">10</span>以上未碰撞第四段</span><br><span class="line">local smul = <span class="number">0.8</span>        --字号倍率</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//.....此次省略N行</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//两个碰撞检测函数</span></span><br><span class="line"><span class="comment">//u=1,2 代码上面和下面柱子</span></span><br><span class="line">local function rectCollision(i,u)</span><br><span class="line">    local K_s_x = sub.x</span><br><span class="line">    local K_s_y = sub.y * ratio</span><br><span class="line">    local K_rect_x = pillar[i].x</span><br><span class="line">    local K_rect_y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    local l = K_rect_x - r </span><br><span class="line">    local r = K_rect_x + r </span><br><span class="line">    local t = <span class="number">0</span></span><br><span class="line">    local b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> u == <span class="number">1</span> then</span><br><span class="line">        t = <span class="number">-1</span></span><br><span class="line">        b = (pillar[i].y - interval_y / <span class="number">2</span>) * ratio</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t = (pillar[i].y + interval_y / <span class="number">2</span>) * ratio</span><br><span class="line">        b = <span class="number">2</span></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local closestP_x = <span class="number">0.0</span></span><br><span class="line">    local closestP_y = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    closestP_x = clamp(K_s_x, l , r)</span><br><span class="line">    closestP_y = clamp(K_s_y, t , b)</span><br><span class="line">    local dist = distance(closestP_x, closestP_y, K_s_x, K_s_y)</span><br><span class="line">    <span class="keyword">if</span> dist &lt;= sub.r * <span class="number">0.9</span> then </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function circleCollision(i,u)</span><br><span class="line">    local K_s_x = sub.x</span><br><span class="line">    local K_s_y = sub.y * ratio</span><br><span class="line">    local K_cir_x = pillar[i].x</span><br><span class="line">    local K_cir_y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u == <span class="number">1</span> then</span><br><span class="line">        K_cir_y = (pillar[i].y - interval_y / <span class="number">2</span>) * ratio</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        K_cir_y = (pillar[i].y + interval_y / <span class="number">2</span>) * ratio</span><br><span class="line">    end</span><br><span class="line">    local dist = distance(K_cir_x, K_cir_y, K_s_x, K_s_y)</span><br><span class="line">    <span class="keyword">if</span> dist &lt;= sub.r * <span class="number">0.9</span> + r then </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>还有两个重要的函数，分别处理预览和录制，游戏过程的逻辑，比如柱子随着时间线一直在移动，speed在加快</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">handleTimerEvent = function(<span class="keyword">this</span>, timerId, milliSeconds)</span><br><span class="line">        <span class="keyword">if</span> timerId == timer_ID_Fast <span class="keyword">and</span> gaming then</span><br><span class="line">            <span class="keyword">if</span> init_state ~= <span class="number">0</span> then</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            timeThis = getTime(<span class="keyword">this</span>)</span><br><span class="line">            timeDelta = getDiffTime(timeLast, timeThis)</span><br><span class="line">            timeCumu = timeCumu + timeDelta</span><br><span class="line">            timeLast = timeThis</span><br><span class="line">            </span><br><span class="line">            local speed = sp[<span class="number">1</span>] + clamp(timeCumu / <span class="number">14</span>, <span class="number">0</span>,<span class="number">1</span>) * (sp[<span class="number">2</span>] - sp[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> timeCumu &gt; <span class="number">14</span> then</span><br><span class="line">                gaming = <span class="literal">false</span></span><br><span class="line">                Sticker2DV3.playClip(<span class="keyword">this</span>, feature_0.folder, feature_0.entity[<span class="number">1</span>], feature_0.clip[<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">                CommonFunc.setFeatureEnabled(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">if</span> score &gt;= <span class="number">10</span> then</span><br><span class="line">                    realTimeFunc.initRealTime(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="literal">true</span>, <span class="keyword">feature_t</span>.realTimeParams[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    realTimeFunc.initRealTime(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="literal">true</span>, <span class="keyword">feature_t</span>.realTimeParams[<span class="number">2</span>])</span><br><span class="line">                end</span><br><span class="line">                realTimeFunc.setRealTime(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="string">"u_data"</span>, score)</span><br><span class="line">                </span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">                pillar[i].x = pillar[i].x - speed * timeDelta</span><br><span class="line">                <span class="keyword">if</span> pillar[i].x &lt; -r then</span><br><span class="line">                    pillar[i].x = pillar[i].x + interval_x * <span class="number">5</span></span><br><span class="line">                    pillar[i].y = range_y[<span class="number">1</span>] + math.random() * (range_y[<span class="number">2</span>] - range_y[<span class="number">1</span>])</span><br><span class="line">                    pillar[i].counted = <span class="literal">false</span></span><br><span class="line">                end</span><br><span class="line">                <span class="keyword">if</span> pillar[i].x &lt; sub.x <span class="keyword">and</span> <span class="keyword">not</span> pillar[i].counted then</span><br><span class="line">                    pillar[i].counted = <span class="literal">true</span></span><br><span class="line">                    score = score + <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                end</span><br><span class="line"></span><br><span class="line">                local cy = pillar[i].y - (interval_y / <span class="number">2</span> - r / ratio) - <span class="number">0.5</span></span><br><span class="line">                local cx = pillar[i].x</span><br><span class="line">                set4Vtx(<span class="keyword">this</span>, feature_3.folder, feature_3.entity[<span class="number">1</span>], feature_3.clip[<span class="number">2</span>*i<span class="number">-1</span>], cx , cy, <span class="number">2</span> * r, <span class="number">1.0</span> , <span class="number">0.0</span>, <span class="number">1.0</span>, ratio, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">                cy = pillar[i].y + (interval_y / <span class="number">2</span> - r / ratio) + <span class="number">0.5</span></span><br><span class="line">                <span class="comment">//更新实体坐标</span></span><br><span class="line">                set4Vtx(<span class="keyword">this</span>, feature_3.folder, feature_3.entity[<span class="number">1</span>], feature_3.clip[<span class="number">2</span>*i], cx , cy, <span class="number">2</span> * r, <span class="number">1.0</span> , <span class="number">0.0</span>, <span class="number">1.0</span>, ratio, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> noseY ~= <span class="number">0</span> then</span><br><span class="line">                sub.y = noseY</span><br><span class="line">            end</span><br><span class="line">            <span class="keyword">if</span> (sub.y ~= <span class="number">0</span> <span class="keyword">or</span> lastY ~= <span class="number">0</span>) then</span><br><span class="line">                sub.a = sub.a * <span class="number">0.8</span> + (sub.y - lastY) / timeDelta * <span class="number">0.2</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sub.a = sub.a * <span class="number">0.8</span></span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            set4Vtx(<span class="keyword">this</span>, feature_2.folder, feature_2.entity[<span class="number">1</span>], feature_2.clip[<span class="number">1</span>], sub.x , sub.y, <span class="number">2</span> * sub.r, <span class="number">2</span> * sub.r / ratio / <span class="number">1.1</span> , sub.a, <span class="number">1.0</span>, ratio, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">						<span class="comment">//对所有柱子遍历做碰撞检测</span></span><br><span class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> rectCollision(i,<span class="number">1</span>) <span class="keyword">or</span> rectCollision(i,<span class="number">2</span>) <span class="keyword">or</span> circleCollision(i,<span class="number">1</span>) <span class="keyword">or</span> circleCollision(i,<span class="number">2</span>) then</span><br><span class="line"></span><br><span class="line">                    gaming = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">if</span> score &lt;= range_s[<span class="number">1</span>] then</span><br><span class="line">                        Sticker2DV3.playClip(<span class="keyword">this</span>, feature_0.folder, feature_0.entity[<span class="number">1</span>], feature_0.clip[<span class="number">4</span>], <span class="number">0</span>)</span><br><span class="line">                    elseif score &lt;= range_s[<span class="number">2</span>] then</span><br><span class="line">                        Sticker2DV3.playClip(<span class="keyword">this</span>, feature_0.folder, feature_0.entity[<span class="number">1</span>], feature_0.clip[<span class="number">3</span>], <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        Sticker2DV3.playClip(<span class="keyword">this</span>, feature_0.folder, feature_0.entity[<span class="number">1</span>], feature_0.clip[<span class="number">2</span>], <span class="number">0</span>)</span><br><span class="line">                    end</span><br><span class="line"></span><br><span class="line">                    CommonFunc.setFeatureEnabled(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="literal">true</span>)</span><br><span class="line">                    <span class="keyword">if</span> score &gt;= <span class="number">10</span> then</span><br><span class="line">                        realTimeFunc.initRealTime(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="literal">true</span>, <span class="keyword">feature_t</span>.realTimeParams[<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        realTimeFunc.initRealTime(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="literal">true</span>, <span class="keyword">feature_t</span>.realTimeParams[<span class="number">2</span>])</span><br><span class="line">                    end</span><br><span class="line">                    realTimeFunc.setRealTime(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="string">"u_data"</span>, score)</span><br><span class="line">                end</span><br><span class="line"></span><br><span class="line">            end</span><br><span class="line">            </span><br><span class="line">            lastY = sub.y</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    end,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    handleRecodeVedioEvent = function (<span class="keyword">this</span>, eventCode)</span><br><span class="line">        <span class="keyword">if</span> (init_state ~= <span class="number">0</span>) then</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        end</span><br><span class="line">        <span class="keyword">if</span> (eventCode == <span class="number">1</span>) then</span><br><span class="line">            timeLast = getTime(<span class="keyword">this</span>)</span><br><span class="line">            timeCumu = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            score = <span class="number">0</span></span><br><span class="line">            gaming = <span class="literal">true</span></span><br><span class="line">            pillar = </span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    x = start_x,</span><br><span class="line">                    y = range_y[<span class="number">1</span>] + math.random() * (range_y[<span class="number">2</span>] - range_y[<span class="number">1</span>]),</span><br><span class="line">                    counted = <span class="literal">false</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    x = start_x + interval_x,</span><br><span class="line">                    y = range_y[<span class="number">1</span>] + math.random() * (range_y[<span class="number">2</span>] - range_y[<span class="number">1</span>]),</span><br><span class="line">                    counted = <span class="literal">false</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    x = start_x + interval_x * <span class="number">2</span>,</span><br><span class="line">                    y = range_y[<span class="number">1</span>] + math.random() * (range_y[<span class="number">2</span>] - range_y[<span class="number">1</span>]),</span><br><span class="line">                    counted = <span class="literal">false</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    x = start_x + interval_x * <span class="number">3</span>,</span><br><span class="line">                    y = range_y[<span class="number">1</span>] + math.random() * (range_y[<span class="number">2</span>] - range_y[<span class="number">1</span>]),</span><br><span class="line">                    counted = <span class="literal">false</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    x = start_x + interval_x * <span class="number">4</span>,</span><br><span class="line">                    y = range_y[<span class="number">1</span>] + math.random() * (range_y[<span class="number">2</span>] - range_y[<span class="number">1</span>]),</span><br><span class="line">                    counted = <span class="literal">false</span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sub = </span><br><span class="line">            &#123;</span><br><span class="line">                r = <span class="number">0.105</span>,</span><br><span class="line">                x = <span class="number">0.24</span>,</span><br><span class="line">                y = <span class="number">0.5</span>,</span><br><span class="line">                sy = <span class="number">0.0</span>,</span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            lastY = noseY</span><br><span class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">                Sticker2DV3.playClip(<span class="keyword">this</span>, feature_3.folder, feature_3.entity[<span class="number">1</span>], feature_3.clip[i], <span class="number">0</span>)</span><br><span class="line">                set4Vtx(<span class="keyword">this</span>, feature_3.folder, feature_3.entity[<span class="number">1</span>], feature_3.clip[i], <span class="number">-2</span> , <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span> , <span class="number">0.0</span>, <span class="number">0.0</span>, ratio, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">            end</span><br><span class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">4</span> <span class="keyword">do</span></span><br><span class="line">                Sticker2DV3.stopClip(<span class="keyword">this</span>, feature_0.folder, feature_0.entity[<span class="number">1</span>], feature_0.clip[i])</span><br><span class="line">            end</span><br><span class="line">            set4Vtx(<span class="keyword">this</span>, feature_2.folder, feature_2.entity[<span class="number">1</span>], feature_2.clip[<span class="number">1</span>], <span class="number">-2</span> , <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">0</span>, ratio, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">            CommonFunc.setFeatureEnabled(<span class="keyword">this</span>, <span class="keyword">feature_t</span>.folder, <span class="literal">false</span>)</span><br><span class="line">        end</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    end,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​        然后有几个stcker文件，可以看到有一个是柱子的entity信息，有一个是潜水艇的entity信息，后面那个游戏失败时弹出的那个框框模型。然后每一个stcker文件夹都有两个json文件，其中主要是clip.json，里面主要包含实体的基本信息，还有transform参数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">"clipname1": &#123;</span><br><span class="line">        "alphaFactor": 1.0,</span><br><span class="line">        "blendmode": 0,</span><br><span class="line">        "fps": 16,</span><br><span class="line">        "height": 801,</span><br><span class="line">        "textureIdx": &#123;</span><br><span class="line">          "idx": [</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">          ],</span><br><span class="line">          "type": "image"</span><br><span class="line">        &#125;,</span><br><span class="line">        "transformParams": &#123;</span><br><span class="line">          "position": &#123;</span><br><span class="line">            "point0": &#123;</span><br><span class="line">              "anchor": [</span><br><span class="line">                0.0,</span><br><span class="line">                <span class="number">0.5</span></span><br><span class="line">              ],</span><br><span class="line">              "point": [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"idx"</span>: <span class="string">"topright"</span>,</span><br><span class="line">                  <span class="attr">"relationRef"</span>: <span class="number">0</span>,</span><br><span class="line">                  <span class="attr">"relationType"</span>: <span class="string">"foreground"</span>,</span><br><span class="line">                  <span class="attr">"weight"</span>: <span class="number">0.5635420937542709</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"idx"</span>: <span class="string">"bottomleft"</span>,</span><br><span class="line">                  <span class="attr">"relationRef"</span>: <span class="number">0</span>,</span><br><span class="line">                  <span class="attr">"relationType"</span>: <span class="string">"foreground"</span>,</span><br><span class="line">                  <span class="attr">"weight"</span>: <span class="number">-0.0793309886223863</span></span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            "point1": &#123;</span><br><span class="line">              "anchor": [</span><br><span class="line">                1.0,</span><br><span class="line">                <span class="number">0.5</span></span><br><span class="line">              ],</span><br><span class="line">              "point": [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"idx"</span>: <span class="string">"topright"</span>,</span><br><span class="line">                  <span class="attr">"relationRef"</span>: <span class="number">0</span>,</span><br><span class="line">                  <span class="attr">"relationType"</span>: <span class="string">"foreground"</span>,</span><br><span class="line">                  <span class="attr">"weight"</span>: <span class="number">0.7854868849874516</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"idx"</span>: <span class="string">"bottomleft"</span>,</span><br><span class="line">                  <span class="attr">"relationRef"</span>: <span class="number">0</span>,</span><br><span class="line">                  <span class="attr">"relationType"</span>: <span class="string">"foreground"</span>,</span><br><span class="line">                  <span class="attr">"weight"</span>: <span class="number">-0.0793309886223863</span></span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          "relation": &#123;</span><br><span class="line">            "foreground": 1</span><br><span class="line">          &#125;,</span><br><span class="line">          "relationIndex": [</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">          ],</span><br><span class="line">          "relationRefOrder": 0,</span><br><span class="line">          "rotationtype": 1,</span><br><span class="line">          "scale": &#123;</span><br><span class="line">            "scaleY": &#123;</span><br><span class="line">              "factor": 1.0</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        ....</span><br></pre></td></tr></table></figure>
<p>总结：    </p>
<p>​    从effect资源可以看出，抖音底层有一个类似游戏引擎的这样的渲染框架，然后通过脚本进行控制。功能也应该是挺齐全的，应该是轻量版的引擎，可是麻雀虽小，五脏俱全。</p>
<p>​        对于熟悉游戏引擎的人来说，这部分应该不难，跟游戏引擎模块类似</p>
<p>​        另外，如果想学习引擎这快，我的思路是多去看看一些流行的开源引擎，一开始模仿别人怎么写，然后不断的思考总结，慢慢的你就知道一个引擎应该包含哪些，以及怎么控制各个模块之间的交互。</p>
<p>​        比如我之前深入研究过OGRE，看过OSG，以及深入研究过THREEJS，同时我自己写的渲染引擎，有把这几个引擎比较好的模块模仿过来，逐渐内化成自己的引擎。</p>
<p>​        后面有机会把拆解一下抖音比较复杂的特效吧，最好找一个和AI或者AR结合的特效(挖坑2)</p>
<h3 id="3-关于音视频图形部分"><a href="#3-关于音视频图形部分" class="headerlink" title="3. 关于音视频图形部分"></a>3. 关于音视频图形部分</h3><p>​        这里主要会大概整理一下比较基础的几个部分，包括滤镜、美颜、特效、转场这些，因为我目前好像只做过这些基础的玩法，更加复杂的就涉及到渲染引擎，还有AI图像方面，后面会继续学习研究</p>
<h4 id="3-1-滤镜篇"><a href="#3-1-滤镜篇" class="headerlink" title="3.1 滤镜篇"></a>3.1 滤镜篇</h4><p>现在的滤镜主要还是查找表的形式包括1D/3D LUT，可能有些也会用AI去做，比如风格化迁移等</p>
<p><strong>1D LUT:</strong></p>
<p>调节亮度，对比度，黑白等级256 x 1，只影响Gamma曲线</p>
<p>RGB曲线调节256 x 3</p>
<p>Instagram 里面有很多1D的LUT应用，比如amaro, lomo, Hudson, Sierra…..</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vec2 uv = gl_FragCoord.st/u_resolution;</span><br><span class="line">    uv.y = <span class="number">1.0</span> - uv.y;</span><br><span class="line"></span><br><span class="line">    vec4 originColor = texture2D(u_texture, uv);</span><br><span class="line">    vec4 texel = texture2D(u_texture, uv);</span><br><span class="line">    vec3 bbTexel = texture2D(u_blowoutTex, uv).rgb;</span><br><span class="line">		<span class="comment">//256x1</span></span><br><span class="line">    texel.r = texture2D(u_overlayTex, vec2(bbTexel.r, texel.r)).r;</span><br><span class="line">    texel.g = texture2D(u_overlayTex, vec2(bbTexel.g, texel.g)).g;</span><br><span class="line">    texel.b = clamp(texture2D(u_overlayTex, vec2(bbTexel.b, texel.b)).b, <span class="number">0.1</span>, <span class="number">0.9</span>);</span><br><span class="line">		<span class="comment">//256x3</span></span><br><span class="line">    vec4 mapped;</span><br><span class="line">    mapped.r = texture2D(u_mapTex, vec2(texel.r, <span class="number">.25</span>)).r;</span><br><span class="line">    mapped.g = texture2D(u_mapTex, vec2(texel.g, <span class="number">.5</span>)).g;</span><br><span class="line">    mapped.b = texture2D(u_mapTex, vec2(texel.b, <span class="number">0.1</span>)).b;</span><br><span class="line">    mapped.a = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    mapped.rgb = mix(originColor.rgb, mapped.rgb, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = mapped;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Amaro 风格</p>
<p><img src="https://i.loli.net/2020/03/30/uyAKFm3Q5n4pDeb.png" alt="amaro.png"></p>
<p>Lomo 风格</p>
<p><img src="https://i.loli.net/2020/03/30/JY8ZePXxi4M9WSC.png" alt="lomo.png"></p>
<p>……</p>
<p><strong>3D LUT:</strong></p>
<p>Lookup table : 64x64 512x512</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这没啥说的，都是很基本的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vec2 uv = gl_FragCoord.st/u_resolution;</span><br><span class="line">    uv.y = <span class="number">1.0</span> - uv.y;</span><br><span class="line">    lowp vec3 textureColor = texture2D(u_texture, uv).rgb;</span><br><span class="line"></span><br><span class="line">    textureColor = clamp((textureColor - vec3(u_levelBlack, u_levelBlack, u_levelBlack)) * u_levelRangeInv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    textureColor.r = texture2D(u_grayTexture, vec2(textureColor.r, <span class="number">0.5</span>)).r;</span><br><span class="line">    textureColor.g = texture2D(u_grayTexture, vec2(textureColor.g, <span class="number">0.5</span>)).g;</span><br><span class="line">    textureColor.b = texture2D(u_grayTexture, vec2(textureColor.b, <span class="number">0.5</span>)).b;</span><br><span class="line"></span><br><span class="line">    mediump <span class="keyword">float</span> blueColor = textureColor.b * <span class="number">15.0</span>;</span><br><span class="line"></span><br><span class="line">    mediump vec2 quad1;</span><br><span class="line">    quad1.y = <span class="built_in">floor</span>(blueColor / <span class="number">4.0</span>);</span><br><span class="line">    quad1.x = <span class="built_in">floor</span>(blueColor) - (quad1.y * <span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line">    mediump vec2 quad2;</span><br><span class="line">    quad2.y = <span class="built_in">floor</span>(<span class="built_in">ceil</span>(blueColor) / <span class="number">4.0</span>);</span><br><span class="line">    quad2.x = <span class="built_in">ceil</span>(blueColor) - (quad2.y * <span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line">    highp vec2 texPos1;</span><br><span class="line">    texPos1.x = (quad1.x * <span class="number">0.25</span>) + <span class="number">0.5</span> / <span class="number">64.0</span> + ((<span class="number">0.25</span> - <span class="number">1.0</span> / <span class="number">64.0</span>) * textureColor.r);</span><br><span class="line">    texPos1.y = (quad1.y * <span class="number">0.25</span>) + <span class="number">0.5</span> / <span class="number">64.0</span> + ((<span class="number">0.25</span> - <span class="number">1.0</span> / <span class="number">64.0</span>) * textureColor.g);</span><br><span class="line"></span><br><span class="line">    highp vec2 texPos2;</span><br><span class="line">    texPos2.x = (quad2.x * <span class="number">0.25</span>) + <span class="number">0.5</span> / <span class="number">64.0</span> + ((<span class="number">0.25</span> - <span class="number">1.0</span> / <span class="number">64.0</span>) * textureColor.r);</span><br><span class="line">    texPos2.y = (quad2.y * <span class="number">0.25</span>) + <span class="number">0.5</span> / <span class="number">64.0</span> + ((<span class="number">0.25</span> - <span class="number">1.0</span> / <span class="number">64.0</span>) * textureColor.g);</span><br><span class="line"></span><br><span class="line">    lowp vec4 newColor1 = texture2D(u_lookupTexture, texPos1);</span><br><span class="line">    lowp vec4 newColor2 = texture2D(u_lookupTexture, texPos2);</span><br><span class="line"></span><br><span class="line">    lowp vec3 newColor = mix(newColor1.rgb, newColor2.rgb, fract(blueColor));</span><br><span class="line"></span><br><span class="line">    textureColor = mix(textureColor, newColor, u_strength);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(textureColor, <span class="number">1.0</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fairytale风格</p>
<p><img src="https://i.loli.net/2020/03/30/uRghixNCAPSlbVs.png" alt="Fairytale.png"></p>
<p>​        可以看到3D LUT看起来更加和谐一点，因为3D LUT 的RGB映射关系是关联在一起，1D LUT则是独立的，不过1D LUT可以节省空间，有些只需要单通道就可以搞定的，就可以用1D LUT</p>
<p>​        LUT得益于其简单的生产流程，基本设计师那边用PhotoShop调好一张查找表，这边就应用上去就OK了</p>
<p>相关资料：</p>
<p><a href="https://affinityspotlight.com/article/1d-vs-3d-luts/" target="_blank" rel="noopener">https://affinityspotlight.com/article/1d-vs-3d-luts/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37147849" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37147849</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/60702944" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60702944</a></p>
<h4 id="3-2-美颜篇"><a href="#3-2-美颜篇" class="headerlink" title="3.2 美颜篇"></a>3.2 美颜篇</h4><ol>
<li><p><strong>磨皮去燥</strong></p>
<p>最简单的方式，就是利用各种降噪滤波器，去掉高频噪声部分</p>
<p>均值模糊 权重分布平均</p>
<p>高斯模糊 权重高斯分布</p>
<p>表面模糊 权重分布只跟颜色空间有关系（与肤色检测配合）</p>
<p>双边滤波 权重分布跟距离和颜色空间分布有关系，</p>
<p>中值模糊 卷积核范围内去中值</p>
<p>导向滤波 参考图像</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">BilateralFilter</span><span class="params">(vec2 uv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> i = uv.x;</span><br><span class="line">    <span class="keyword">float</span> j = uv.y;</span><br><span class="line">    <span class="keyword">float</span> sigmaSSquare = <span class="number">2.0</span> * SigmaS * SigmaS;</span><br><span class="line">    <span class="keyword">float</span> sigmaRSquare = <span class="number">2.0</span> * SigmaR * SigmaR;</span><br><span class="line">    vec3 centerColor = texture2D(u_texture, uv).rgb;</span><br><span class="line">    <span class="keyword">float</span> centerGray = Luminance(centerColor);</span><br><span class="line">    vec3 sum_up, sum_down;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = -u_radius; k &lt;= u_radius; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = -u_radius; l &lt;= u_radius; l++) &#123;</span><br><span class="line">            vec2 uv_new = uv + vec2(k, l)/u_resolution;</span><br><span class="line">            vec3 curColor = texture2D(u_texture, uv_new).rgb;</span><br><span class="line">            <span class="keyword">float</span> curGray = Luminance(curColor);</span><br><span class="line">            vec3 deltaColor = curyolor - centerColor;</span><br><span class="line">            <span class="keyword">float</span> len = dot(deltaColor, deltaColor);</span><br><span class="line">            <span class="keyword">float</span> exponent = -((i-k)*(i-k)+(j-l)*(j-l))/sigmaSSquare - len/sigmaRSquare;</span><br><span class="line">            <span class="keyword">float</span> weight = <span class="built_in">exp</span>(exponent);</span><br><span class="line">            sum_up += curColor * weight;</span><br><span class="line">            sum_down += weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 color = sum_up / sum_down;</span><br><span class="line">    <span class="keyword">return</span> vec4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vec4 <span class="title">SurfaceFilter</span><span class="params">(vec2 uv)</span> </span>&#123;</span><br><span class="line">    vec3 centerColor = texture2D(u_texture, uv).rgb;</span><br><span class="line">    vec3 sum_up, sum_down;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = -u_radius; k &lt;= u_radius; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = -u_radius; l &lt;= u_radius; l++) &#123;</span><br><span class="line">            vec2 uv_new = uv + vec2(k, l)/u_resolution;</span><br><span class="line">            vec3 curColor = texture2D(u_texture, uv_new).rgb;</span><br><span class="line">            vec3 weight = CalculateWeight(curColor, centerColor);</span><br><span class="line">            sum_up += weight * curColor;</span><br><span class="line">            sum_down += weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec4(sum_up / sum_down, <span class="number">1.0</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec4 <span class="title">gaussian</span><span class="params">(vec2 uv, <span class="keyword">bool</span> horizontalPass)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">float</span> numBlurPixelsPerSide = <span class="keyword">float</span>(blurSize / <span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">  vec2 blurMultiplyVec = <span class="number">0</span> &lt; horizontalPass ? vec2(<span class="number">1.0</span>, <span class="number">0.0</span>) : vec2(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//高斯函数</span></span><br><span class="line">  vec3 incrementalGaussian;</span><br><span class="line">  incrementalGaussian.x = <span class="number">1.0</span> / (<span class="built_in">sqrt</span>(<span class="number">2.0</span> * pi) * sigma);</span><br><span class="line">  incrementalGaussian.y = <span class="built_in">exp</span>(<span class="number">-0.5</span> / (sigma * sigma));</span><br><span class="line">  incrementalGaussian.z = incrementalGaussian.y * incrementalGaussian.y;</span><br><span class="line"> </span><br><span class="line">  vec4 avgValue = vec4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">  <span class="keyword">float</span> coefficientSum = <span class="number">0.0</span>;</span><br><span class="line"> </span><br><span class="line">  avgValue += texture2D(texture, vertTexCoord.st) * incrementalGaussian.x;</span><br><span class="line">  coefficientSum += incrementalGaussian.x;</span><br><span class="line">  incrementalGaussian.xy *= incrementalGaussian.yz;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">float</span> i = <span class="number">1.0</span>; i &lt;= numBlurPixelsPerSide; i++) &#123; </span><br><span class="line">    avgValue += texture2D(texture, vertTexCoord.st - i * texOffset * </span><br><span class="line">                          blurMultiplyVec) * incrementalGaussian.x;         </span><br><span class="line">    avgValue += texture2D(texture, vertTexCoord.st + i * texOffset * </span><br><span class="line">                          blurMultiplyVec) * incrementalGaussian.x;         </span><br><span class="line">    coefficientSum += <span class="number">2.0</span> * incrementalGaussian.x;</span><br><span class="line">    incrementalGaussian.xy *= incrementalGaussian.yz;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> avgValue / coefficientSum;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>比如双边滤波的效果</p>
<p><img src="https://i.loli.net/2020/03/30/8afbrAPmGDF9hq5.png" alt="bilateral.png"></p>
<p>高斯效果</p>
<p><img src="https://i.loli.net/2020/03/30/qMcWOY5Ng24LH9D.png" alt="gaussian.png" style="zoom:50%;"></p>
<p>suface blur 配合肤色检测，可以看出边缘部分有点硬，</p>
<p><img src="https://i.loli.net/2020/03/30/a7jLmSHZ9tNFEwO.png" alt="surface.png" style="zoom:50%;"></p>
<p>2.<strong>美白</strong></p>
<p>HighPass高亮加一点红晕</p>
<p><img src="https://i.loli.net/2020/03/30/tZvFGQOlMb13kTd.png" alt="highpass.png"></p>
<p>3.<strong>美型</strong></p>
<p>美型主要是需要和人脸检测结合起来，对人脸各个部位进行微调，比如：</p>
<ul>
<li>廋脸，根据AI找到的固定脸型的那几个关键点，在各自方向做曲线变形处理</li>
<li>大眼，找到中心点，放大一定的半径</li>
<li>下巴，也是做曲线变形处理</li>
</ul>
<p>类似如下的曲线变形处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 曲线形变处理</span></span><br><span class="line"><span class="function">vec2 <span class="title">curveWarp</span><span class="params">(vec2 textureCoord, vec2 originPosition, vec2 targetPosition, <span class="keyword">float</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 offset = vec2(<span class="number">0.0</span>);</span><br><span class="line">    vec2 result = vec2(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    vec2 direction = targetPosition - originPosition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> infect = distance(textureCoord, originPosition)/radius;</span><br><span class="line"></span><br><span class="line">    infect = <span class="number">1.0</span> - infect;</span><br><span class="line">    infect = clamp(infect, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    offset = direction * infect;</span><br><span class="line"></span><br><span class="line">    result = textureCoord - offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>……</p>
<p>​    这一块主要是需要准确的关键点处理，然后就是怎么调整曲线了，可以自己注册一个Face++的FaceDetect自己玩一下，包括怎么和贴纸配合，这一块还在总结中，后续会自己研究(挖坑3)</p>
<h4 id="3-3-转场篇"><a href="#3-3-转场篇" class="headerlink" title="3.3 转场篇"></a>3.3 转场篇</h4><p>​        转场主要是涉及到两段视频之间，Shader会有两个Input，然后通过progress控制进度，我理解的转场主要包括以下这些：</p>
<p><strong>1.UV变换</strong></p>
<p>转场很多其实都是UV变化，UV坐标围绕某个点旋转、缩放、平移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scale center</span></span><br><span class="line">vec2 scale_uv = vec2(<span class="number">0.5</span> + (tc.x - <span class="number">0.5</span>) / scaleU , <span class="number">0.5</span> + (tc.y - <span class="number">0.5</span>) / scaleV );</span><br><span class="line"></span><br><span class="line"><span class="comment">//rotate</span></span><br><span class="line"><span class="function">vec2 <span class="title">rotateUV</span><span class="params">(vec2 uv, <span class="keyword">float</span> rotation, vec2 mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> ratio = (resolution.x / resolution.y);</span><br><span class="line">  <span class="keyword">float</span> s = <span class="built_in">sin</span> ( rotation );</span><br><span class="line">  <span class="keyword">float</span> c = <span class="built_in">cos</span> ( rotation );</span><br><span class="line">  mat2 rotationMatrix = mat2( c, -s, s, c);</span><br><span class="line">  vec2 coord = vec2((uv.x - mid.x) * ratio ,(uv.y -mid.y)*<span class="number">1.0</span>);</span><br><span class="line">  vec2 scaled = rotationMatrix * coord;</span><br><span class="line">  <span class="keyword">return</span> vec2(scaled.x / ratio + mid.x,scaled.y + mid.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//translate</span></span><br><span class="line">vec2 translate_uv = vec2(<span class="number">0.5</span> + (tc.x - <span class="number">0.5</span>) / scaleU , <span class="number">0.5</span> + (tc.y - <span class="number">0.5</span>) / scaleV );</span><br></pre></td></tr></table></figure>
<p>怎么控制进度就慢慢调吧</p>
<p><strong>2.Blend转场</strong></p>
<p>首先熟悉一下PhotoShop里面的混合模式alphe混合、滤色、加深、减淡、高亮度等等</p>
<p><a href="https://zhuanlan.zhihu.com/p/23905865" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23905865</a></p>
<p>然后就可以慢慢玩了</p>
<p><strong>3.模糊转场</strong></p>
<p>主要也是Photoshop里面的几种模糊方式，旋转模糊、高斯模糊、均值模糊等等</p>
<p>需要注意一下旋转模糊，我实现过一种旋转模糊的转场，需要配合随机采样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand</span><span class="params">(vec2 uv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fract(<span class="built_in">sin</span>(dot(uv.xy ,vec2(<span class="number">12.9898</span>,<span class="number">78.233</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vec4 <span class="title">rotation_blur</span><span class="params">(vec2 tc)</span> </span>&#123;</span><br><span class="line">  angle = angle * PI_ROTATION / <span class="number">180.0</span>;</span><br><span class="line">  vec2 uv = tc;</span><br><span class="line">  <span class="keyword">float</span> uv_random = rand(uv);</span><br><span class="line">  vec4 sum_color = vec4(<span class="number">0.0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">float</span> i = <span class="number">0.0</span>; i &lt; samples; i++) &#123;</span><br><span class="line">    <span class="keyword">float</span> percent = (i + uv_random) / samples;</span><br><span class="line">    <span class="keyword">float</span> real_angle = angle + percent * strength;</span><br><span class="line">    real_angle = mod(real_angle, PI_ROTATION);</span><br><span class="line">    vec2 uv_rotation = rotateUV(uv, real_angle, center);</span><br><span class="line">    sum_color += INPUT(fract(uv_rotation));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum_color / samples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And 这里有个转场的网站，可以研究一下</p>
<p><a href="https://gl-transitions.com/" target="_blank" rel="noopener">https://gl-transitions.com/</a></p>
<h4 id="3-4-特效篇"><a href="#3-4-特效篇" class="headerlink" title="3.4 特效篇"></a>3.4 特效篇</h4><p>基础的特效包括：抖动、灵魂出窍、故障风、光晕、老电影、粒子特效等等</p>
<p>比如old film</p>
<p><img src="https://i.loli.net/2020/03/30/GutfwzVTk2LlC1h.png" alt="old_film.png" style="zoom:50%;"></p>
<p>比如glitch风格(动态的会好一点)</p>
<p><img src="https://i.loli.net/2020/03/30/sPNvIylF56gkYzQ.png" alt="glitch.png" style="zoom:50%;"></p>
<p>​       这些特效都不难，网上Shader到处都是，基本copy下来调调参数就行，可能也就粒子特效需要调很多细节，但如果你有图形引擎的基础，这些都很简单，到时候我可以建个仓库，share一些我自己实现的shader</p>
<p>一般特效的话可以先去网上找，比如shadertoy</p>
<p><a href="https://www.shadertoy.com/" target="_blank" rel="noopener">https://www.shadertoy.com/</a></p>
<p>如果找不到的话，需要自己去想怎么实现，我一般是会按如下的方式去思考：</p>
<ol>
<li>善于利用各种卷积滤波器(边缘检测、模糊)，有时候需要和随机采样结合</li>
<li>熟悉各种颜色空间，熟悉饱和度、锐度、亮度、色度等基础调节</li>
<li>UV变换多写几个有经验了，然后理解一些曲线函数，基本都能慢慢调出来</li>
<li>可以试着看看相关论文，或者OpenCV的实现方式</li>
</ol>
<p>简单的特效实现起来并不难，多去写，慢慢总结经验的套路，如果更深入一点可能需要图形图像和数学的知识</p>
<h4 id="3-5-串联这些效果"><a href="#3-5-串联这些效果" class="headerlink" title="3.5 串联这些效果"></a>3.5 串联这些效果</h4><p>​    可能大家比较熟悉的就是GPUImage了，基本都是用这个去串联这些特效、滤镜之类，关于GPUImage网上也有很多资料，这里就不具体讲了，也比较简单，内部就是一个Input一个output通过FBO串起来。这里主要想推荐大家看下movit这个框架，基本跟GPUImage类似，支持单个input和多个input，可以打断中间节点，也可以有FrameBufferCache机制，但他还有一个优化的点就是，Shader动态组装机制，熟悉游戏引擎应该都知道这个，Shader是可以在最后动态生成，他里面是通过宏define来控制，可以把一些列串联特效组装到一起，非常高效，后面可以单独讲讲这块。</p>
<p>只需要看下他组装shader的过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; phase-&gt;effects.size(); ++i) &#123;</span><br><span class="line">	Node *node = phase-&gt;effects[i];</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">string</span> effect_id = phase-&gt;effect_ids[make_pair(node, IN_SAME_PHASE)];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; node-&gt;incoming_links.size(); ++j) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;incoming_links.size() == <span class="number">1</span>) &#123;</span><br><span class="line">			frag_shader += <span class="string">"#define INPUT"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">"#define INPUT%d"</span>, j + <span class="number">1</span>);</span><br><span class="line">			frag_shader += buf;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Node *input = node-&gt;incoming_links[j];</span><br><span class="line">		NodeLinkType link_type = node-&gt;incoming_link_type[j];</span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    input-&gt;effect-&gt;is_compute_shader() &amp;&amp;</span><br><span class="line">		    node-&gt;incoming_link_type[j] == IN_SAME_PHASE) &#123;</span><br><span class="line">			<span class="comment">// First effect after the compute shader reads the value</span></span><br><span class="line">			<span class="comment">// that cs_output() wrote to a global variable,</span></span><br><span class="line">			<span class="comment">// ignoring the tc (since all such effects have to be</span></span><br><span class="line">			<span class="comment">// strong one-to-one).</span></span><br><span class="line">			frag_shader += <span class="string">"(tc) CS_OUTPUT_VAL\n"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			assert(phase-&gt;effect_ids.count(make_pair(input, link_type)));</span><br><span class="line">			frag_shader += <span class="built_in">string</span>(<span class="string">" "</span>) + phase-&gt;effect_ids[make_pair(input, link_type)] + <span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	frag_shader += <span class="string">"\n"</span>;</span><br><span class="line">	frag_shader += <span class="built_in">string</span>(<span class="string">"#define FUNCNAME "</span>) + effect_id + <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;effect-&gt;is_compute_shader()) &#123;</span><br><span class="line">		frag_shader += <span class="built_in">string</span>(<span class="string">"#define NORMALIZE_TEXTURE_COORDS(tc) ((tc) * "</span>) + effect_id + <span class="string">"_inv_output_size + "</span> + effect_id + <span class="string">"_output_texcoord_adjust)\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	frag_shader += replace_prefix(node-&gt;effect-&gt;output_fragment_shader(), effect_id);</span><br><span class="line">	frag_shader += <span class="string">"#undef FUNCNAME\n"</span>;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;incoming_links.size() == <span class="number">1</span>) &#123;</span><br><span class="line">		frag_shader += <span class="string">"#undef INPUT\n"</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; node-&gt;incoming_links.size(); ++j) &#123;</span><br><span class="line">			<span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">"#undef INPUT%d\n"</span>, j + <span class="number">1</span>);</span><br><span class="line">			frag_shader += buf;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	frag_shader += <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完了之后可以生成类似如下的shader：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">precision highp <span class="keyword">float</span>;</span><br><span class="line">varying vec2 tc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCNAME eff0</span></span><br><span class="line">uniform sampler2D eff0_tex;</span><br><span class="line"><span class="function">vec4 <span class="title">FUNCNAME</span><span class="params">(vec2 tc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> texture2D(eff0_tex, vec2(tc.x,<span class="number">1.0</span>-tc.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PREFIX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> FUNCNAME</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT eff0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCNAME eff1</span></span><br><span class="line">uniform <span class="keyword">float</span> eff1_strength;</span><br><span class="line">uniform sampler2D eff1_lut;</span><br><span class="line"><span class="function">vec4 <span class="title">FUNCNAME</span><span class="params">(vec2 tc)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">float</span> strength = eff1_strength;</span><br><span class="line">    lowp vec4 textureColor = INPUT(tc); </span><br><span class="line">    mediump <span class="keyword">float</span> blueColor = textureColor.b * <span class="number">63.0</span>;</span><br><span class="line">    mediump vec2 quad1; quad1.y = <span class="built_in">floor</span>(<span class="built_in">floor</span>(blueColor) / <span class="number">8.0</span>); </span><br><span class="line">    quad1.x = <span class="built_in">floor</span>(blueColor) - (quad1.y * <span class="number">8.0</span>); </span><br><span class="line">    mediump vec2 quad2; </span><br><span class="line">    quad2.y = <span class="built_in">floor</span>(<span class="built_in">ceil</span>(blueColor) / <span class="number">8.0</span>); </span><br><span class="line">    quad2.x = <span class="built_in">ceil</span>(blueColor) - (quad2.y * <span class="number">8.0</span>); </span><br><span class="line">    highp vec2 texPos1; </span><br><span class="line">    texPos1.x = (quad1.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r); </span><br><span class="line">  	texPos1.y = (quad1.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g);</span><br><span class="line">    highp vec2 texPos2; </span><br><span class="line">    texPos2.x = (quad2.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r);</span><br><span class="line">    texPos2.y = (quad2.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g);</span><br><span class="line">    lowp vec4 newColor1 = texture2D(eff1_lut, texPos1); </span><br><span class="line">    lowp vec4 newColor2 = texture2D(eff1_lut, texPos2); </span><br><span class="line">    lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor)); </span><br><span class="line">    <span class="keyword">return</span> mix(textureColor, vec4(newColor.rgb, textureColor.w), strength);</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PREFIX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> FUNCNAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> INPUT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT eff1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_FragColor = INPUT(tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        直接通过一个#define FUNCNAME就可以串起来，我以前写的那个渲染引擎，也是动态组装shader，跟这个有点类似，不过比这个复杂，需要更多的宏来控制，有兴趣可以去看看</p>
<p>Movit源码：<a href="https://git.sesse.net/?p=movit;a=summary" target="_blank" rel="noopener">https://git.sesse.net/?p=movit;a=summary</a></p>
<h3 id="4-关于音视频处理"><a href="#4-关于音视频处理" class="headerlink" title="4. 关于音视频处理"></a>4. 关于音视频处理</h3><h4 id="4-1-音视频理论知识"><a href="#4-1-音视频理论知识" class="headerlink" title="4.1 音视频理论知识"></a>4.1 音视频理论知识</h4><ol>
<li>H264/H265编码原理，宏快怎么划分</li>
<li>I、P、B帧压缩方式</li>
<li>SPS/PPS 信息</li>
<li>音频的采样率</li>
<li>封装格式(MP4, FLV)，MP4的Box形式存储</li>
<li>YUV数据</li>
</ol>
<h4 id="4-2-编解码部分"><a href="#4-2-编解码部分" class="headerlink" title="4.2 编解码部分"></a>4.2 编解码部分</h4><p>音视频解码基本流程</p>
<p><img src="https://i.loli.net/2020/03/30/WlHf3MyvSE5XI61.jpg" alt="codec.jpeg"></p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/18893769" target="_blank" rel="noopener">https://blog.csdn.net/leixiaohua1020/article/details/18893769</a></p>
<p>1.<strong>硬解部分(Android MediaCodec)</strong></p>
<p>在低端平台更多的需要依赖硬件解码，效率会更高，Android MediaCodec</p>
<p><img src="https://i.loli.net/2020/03/30/pb9zQeStANWLZf1.png" alt="mediacodec.png"></p>
<p><a href="https://developer.android.com/reference/android/media/MediaCodec?hl=en" target="_blank" rel="noopener">https://developer.android.com/reference/android/media/MediaCodec?hl=en</a></p>
<p>大概的代码逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!m_sawOutputEOS) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!m_sawInputEOS) &#123;</span><br><span class="line">				<span class="comment">// Feed more data to the decoder</span></span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> inputBufIndex = m_decoder.dequeueInputBuffer(TIMEOUT_USEC);</span><br><span class="line">				<span class="keyword">if</span> (inputBufIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					ByteBuffer inputBuf = m_decoderInputBuffers[inputBufIndex];</span><br><span class="line">					<span class="comment">// Read the sample data into the ByteBuffer. This neither</span></span><br><span class="line">					<span class="comment">// respects nor</span></span><br><span class="line">					<span class="comment">// updates inputBuf's position, limit, etc.</span></span><br><span class="line">					<span class="keyword">final</span> <span class="keyword">int</span> chunkSize = m_extractor.readSampleData(inputBuf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (m_verbose)</span><br><span class="line">						Log.d(TAG, <span class="string">"input packet length: "</span> + chunkSize + <span class="string">" time stamp: "</span> + m_extractor.getSampleTime());</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (chunkSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">// End of stream -- send empty frame with EOS flag set.</span></span><br><span class="line">						m_decoder.queueInputBuffer(inputBufIndex, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0L</span>, MediaCodec.BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">						m_sawInputEOS = <span class="keyword">true</span>;</span><br><span class="line">						<span class="keyword">if</span> (m_verbose)</span><br><span class="line">							Log.d(TAG, <span class="string">"Sent input EOS"</span>);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (m_extractor.getSampleTrackIndex() != m_videoTrackIndex) &#123;</span><br><span class="line">							Log.w(TAG, <span class="string">"WEIRD: got sample from track "</span> + m_extractor.getSampleTrackIndex()</span><br><span class="line">									+ <span class="string">", expected "</span> + m_videoTrackIndex);</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">long</span> presentationTimeUs = m_extractor.getSampleTime();</span><br><span class="line"></span><br><span class="line">						m_decoder.queueInputBuffer(inputBufIndex, <span class="number">0</span>, chunkSize, presentationTimeUs, <span class="number">0</span>);</span><br><span class="line">						<span class="keyword">if</span> (m_verbose)</span><br><span class="line">							Log.d(TAG,</span><br><span class="line">									<span class="string">"Submitted frame to decoder input buffer "</span> + inputBufIndex + <span class="string">", size="</span> + chunkSize);</span><br><span class="line"></span><br><span class="line">						m_inputBufferQueued = <span class="keyword">true</span>;</span><br><span class="line">						++m_pendingInputFrameCount;</span><br><span class="line">						<span class="keyword">if</span> (m_verbose)</span><br><span class="line">							Log.d(TAG, <span class="string">"Pending input frame count increased: "</span> + m_pendingInputFrameCount);</span><br><span class="line"></span><br><span class="line">						m_extractor.advance();</span><br><span class="line">						m_extractorInOriginalState = <span class="keyword">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (m_verbose)</span><br><span class="line">						Log.d(TAG, <span class="string">"Input buffer not available"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> decoderStatus = m_decoder.dequeueOutputBuffer(m_bufferInfo, dequeueTimeoutUs);</span><br><span class="line">	<span class="keyword">if</span> (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">				<span class="comment">// No output available yet</span></span><br><span class="line">				<span class="keyword">if</span> (m_verbose)</span><br><span class="line">					Log.d(TAG, <span class="string">"No output from decoder available"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">				<span class="comment">// Not important for us, since we're using Surface</span></span><br><span class="line">				<span class="keyword">if</span> (m_verbose)</span><br><span class="line">					Log.d(TAG, <span class="string">"Decoder output buffers changed"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">				MediaFormat newFormat = m_decoder.getOutputFormat();</span><br><span class="line">				<span class="keyword">if</span> (m_verbose)</span><br><span class="line">					Log.d(TAG, <span class="string">"Decoder output format changed: "</span> + newFormat);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (decoderStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				Log.e(TAG, <span class="string">"Unexpected result from decoder.dequeueOutputBuffer: "</span> + decoderStatus);</span><br><span class="line">				<span class="keyword">return</span> ERROR_FAIL;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="comment">///....</span></span><br><span class="line">        m_decoder.releaseOutputBuffer(decoderStatus, doRender);</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>
<p>解码过程网上到处都是，解码主要就是配合MediaExtrator，直接说一下需要注意的点：</p>
<ul>
<li>getOutputBuffer得到的数据格式主要是YUV420P和YUV420SP，UV通道排列不一样</li>
<li>seekTo完之后要Flush</li>
<li>configure如果传入surface则是直接decode到suface上，不同通过getOutputBuffer获取数据</li>
</ul>
<p>2.<strong>软解部分(FFMPEG)</strong></p>
<p>​         其实现在绝大部分音视频APP编解码都是用的FFMPEG，这里门也包含了硬解MediaCodec部分，所以只需要用FFMPEG就可以做硬解和软解的切换。关于FFMPEG的学习，首推肯定是雷神的博客啦，</p>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/15811977" target="_blank" rel="noopener">https://blog.csdn.net/leixiaohua1020/article/details/15811977</a></p>
<p>主要包括两个部分，首先是prepare部分，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avformat_open_input(&amp;mFormatContext, path.c_str(), <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        mlt_log_error(mProducer, <span class="string">"Could not open input file: %s"</span>, path.c_str());</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (avformat_find_stream_info(mFormatContext, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  mlt_log_error(mProducer, <span class="string">"Could not find stream information"</span>);</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVideoStreamIndex = findPreferedVideoStream();<span class="comment">//遍历track找到视频轨</span></span><br><span class="line">mVideoStream = mFormatContext-&gt;streams[mVideoStreamIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后就可以得到一些列参数，width，height，fps，fromat</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是硬解</span></span><br><span class="line"><span class="comment">//根据不同的编码器，找到对应的解码器，如H264，H265等</span></span><br><span class="line">mVideoCodec = avcodec_find_decoder_by_name(<span class="string">"h264_mediacodec"</span>);;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是软解</span></span><br><span class="line">mVideoCodec = avcodec_find_decoder(mVideoStream-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//open</span></span><br><span class="line">avcodec_open2(mVideoCodecContext, mVideoCodec, <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">//就可以开始解码了</span></span><br></pre></td></tr></table></figure>
<p>解码部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mPacket) &#123;</span><br><span class="line">            ret = getVideoPacket();</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//这里面送包的时候有很多细节</span></span><br><span class="line">  			<span class="keyword">int</span> ret = avcodec_send_packet(mVideoCodecContext, flush ? <span class="literal">NULL</span> : mPacket);</span><br><span class="line">  			<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">            freeVideoPacket();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF &amp;&amp; ret != AVERROR(EAGAIN)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = avcodec_receive_frame(mVideoCodecContext, mFrame);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            ret = DECODER_FFMPEG_SUCCESS;</span><br><span class="line">          	<span class="comment">//计算pts</span></span><br><span class="line">            mCurrentPos = getTime(mFrame-&gt;pts == AV_NOPTS_VALUE ? mFrame-&gt;pkt_dts : mFrame-&gt;pts);</span><br><span class="line">            pts = mCurrentPos;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++count;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret &lt; DECODER_FFMPEG_SUCCESS &amp;&amp; count &lt; DECODER_TRY_ATTEMPTS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面就是针对不同的格式，接入数据，</span></span><br><span class="line"><span class="comment">//还可以通过swscaleFrame进行转码，转成你想要的格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后就是copy AVFrame里面的数据啦</span></span><br></pre></td></tr></table></figure>
<p>关于FFMPEG有太多可以去学习的了，比如：</p>
<ul>
<li>学会用ffmpeg ffprobe ffplay一些命令，真的非常强大，方便分析问题(ffprobe -i xxxx)</li>
<li>怎么去切换软解和硬码</li>
<li>熟悉API返回的状态</li>
</ul>
<p><strong>然后就是兼容性的问题</strong>：</p>
<p>​      由于Android平台太复杂了，厂商很多，所以会有无穷无尽的兼容性问题需要去解决，总体来说兼容性问题主要包括：</p>
<ul>
<li>数据源的兼容性，YUV格式非常多样，420p/420sp是常见的，还有yuv420p10le 这种10bit，贼坑</li>
<li>硬件平台的兼容性，这里坑就更多了，MediaCodec支持程度，尤其是低端机非常需要注意</li>
<li>分辨率问题，4K/8K，高通平台的支持程度</li>
</ul>
<p>这个后续单独去整理吧……(挖坑4)</p>
<h4 id="4-3-音视频同步"><a href="#4-3-音视频同步" class="headerlink" title="4.3 音视频同步"></a>4.3 音视频同步</h4><p>视音频同步的实现方式其实有三种，分别是：</p>
<ul>
<li>以音频为主时间轴作为同步源;</li>
<li>以视频为主时间轴作为同步源;</li>
<li><p>以外部时钟为主时间轴作为同步源;</p>
<p>​具体用哪一种需要根据场景，比如在线视频播放器，一般会以第一种音频作为主时间轴去对齐视频帧数据，做丢帧和用当前帧处理，比如我之前写的音视频编辑SDK，因为我们有一条固定帧率的时间线，所以我们的对齐方式是以这条固定时间轴来对齐视频。</p>
<p>​比如当前时间轴如果大于当前decode出来的帧的pts，就直接丢掉，继续找下一帧，如果当前时间轴小于decode出来的帧的pts，超过1一帧的时间就继续用上一帧渲染即可。</p>
</li>
</ul>
<h4 id="4-4-多视频多轨道-进阶"><a href="#4-4-多视频多轨道-进阶" class="headerlink" title="4.4 多视频多轨道(进阶)"></a>4.4 多视频多轨道(进阶)</h4><p><img src="https://i.loli.net/2020/03/30/Eng8sV6jF1NQfdr.png" alt="multi_track.png"></p>
<p>​        视频编辑SDK肯定是需要支持多视频多轨道编辑，如何高效的管理，方便编辑和预览，这里面主要是需要一个好的Multi track的框架支撑，组里面大佬把MLT框架直接拿过用了，这个框架对于多视频多轨道处理真的非常强大，内部有精确的时间戳对齐逻辑，也可以和很多插件配合使用</p>
<p>​    基本框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+   +------+   +--------+</span><br><span class="line">|Producer|--&gt;|Filter|--&gt;|Consumer|</span><br><span class="line">+--------+   +------+   +--------+</span><br></pre></td></tr></table></figure>
<p>具体看Github</p>
<p><a href="https://github.com/mltframework/mlt" target="_blank" rel="noopener">https://github.com/mltframework/mlt</a></p>
<h3 id="5-关于传输"><a href="#5-关于传输" class="headerlink" title="5. 关于传输"></a>5. 关于传输</h3><p>这块没做过，对传输协议不太了解，只知道一些理论知识，比如RTMP的分块传输，后面有机会再补齐</p>
<h4 id="5-1-RTMP"><a href="#5-1-RTMP" class="headerlink" title="5.1 RTMP"></a>5.1 RTMP</h4><h3 id="6-分析音视频APP"><a href="#6-分析音视频APP" class="headerlink" title="6. 分析音视频APP"></a>6. 分析音视频APP</h3><p>​    在开发过程中，对于一个小白来说可能会经常遇到一筹莫展的时候，这时候要学会向同类优秀的应用学习，比如做短视频相关的可以去看抖音/快手怎么做的，做音视频剪辑相关的可以看看见剪映/快影/小影怎么做的，你可以去把他们的包pull出来，比如我在做资源的接入的时候，就对比过快手/抖音/大疆 这几家的资源，看他们的sticker怎样接入，有png序列，有MP4，有自定义GIF格式的。所以从这些APP的packge内部还是能找到一些线索，跟着这些线索再慢慢找到其内部的逻辑，就比如我上面分析抖音潜水艇那个游戏一样，当然也可以去分析其它的一些文件，给你提供思路。</p>
<h4 id="1-抖音"><a href="#1-抖音" class="headerlink" title="1. 抖音"></a>1. 抖音</h4><p>Package name: com.ss.android.ugc.aweme</p>
<p>adb pull /data/data/com.ss.android.ugc.aweme</p>
<p><img src="https://i.loli.net/2020/03/30/1edpLhX8VuN9HwI.png" alt="tiktok_package.png" style="zoom:50%;"></p>
<p>主要是分析了一下里面的Effect资源，还有LOG信息, 后面可以有机会继续拆解一下(挖坑5)</p>
<h4 id="2-快手"><a href="#2-快手" class="headerlink" title="2. 快手"></a>2. 快手</h4><p>Package name: com.smile.gifmaker</p>
<p>同样的方式</p>
<h4 id="3-大疆"><a href="#3-大疆" class="headerlink" title="3. 大疆"></a>3. 大疆</h4><p>Package name: dji.mimo</p>
<p>​    主要是DJI mimo，但是做的比较烂，所以没有太多可分析的，不过通过他们的sticker资源可以看到他们支持alpha通道视频的原理，后面有类似需求也可以拿过来用</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>现在是凌晨3点多，从周日从早上开始写到晚上3点，差不多用了将近18个小时来整理[吐血]。想想上一次博客更新差不多是两年前了，那时候是做图形渲染相关的事情，也试着自己写了一个渲染引擎，结合了不错的开源引擎，写完之后对我图形方向的理解有很大的进步，于是试着开始写了几篇博客，继续维护自己关于图形方向的研究，后面由于各种原因，没有继续在维护之前的图形引擎，自己也不在更新博客了。</p>
<p>​    今天以音视频作为新的方向，重新回来，把自己这两年的一些积累整理出来，希望能对后面的学习者有所帮助，我也会尽力去打磨好每一篇博客，今天这遍博客只是总结一个大的框架，里面有非常非常多的细节，都可单独用一篇文章去讲，比如关于Camera，音视频特效，编解码，兼容性这些，都需要花时间去一点一点研究。我也会对自己每一篇文章有严格的要求，要么不写，要写就尽量按照论文的形式把每一个点讲清楚，结合流程图和效果图，最后还需要给出Demo复现效果。</p>
<p>​    还是开头那句话，随着5G是时代的到来，音视频的应用将会更加普及，这方面的人才也会更加紧缺，同时对于这里面的技术要求也会越来越高，从现在开始就慢慢积累，完善里面的技能栈，也可以选择一个分支去深入下去，这里面有很多的方向都值得研究。也希望以这篇文章为起点，寻找一些志同道合之人，一起去探索一些音视频方向的玩法，当然还有相机这块，因为我之前一直是做相机相关的，也思考过相机有什么好的方向可以去探索。</p>
<p>​    总之，我会一直做音视频这个方向，抖音和快手在视频玩法上做到了极致，手机厂商不断的升级Camera，也越来越重视视频的采集，让手机作为拍摄工具可以拍出更加震撼的效果，还有大疆在无人机领域视角去采集的视频数据，也可以做出很多大片效果，还有Insta360在全景方向的玩法，做的也很棒，未来随着硬件设备的升级，还会出现更多有趣的玩法，比如和AR/VR结合在一起，又会有怎样的火花呢，我们拭目以待。</p>
<blockquote>
<p>人生只有一次，做自己喜欢的事吧</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 音视频 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图形图像 </tag>
            
            <tag> 音视频 </tag>
            
            <tag> Camera </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SimpleRenderEngineV1.0功能设计思想]]></title>
      <url>/2017/12/15/%EF%BC%88url%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E6%A0%87%E9%A2%98%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-SimpleRenderEngine初衷"><a href="#1-SimpleRenderEngine初衷" class="headerlink" title="1.SimpleRenderEngine初衷"></a>1.SimpleRenderEngine初衷</h3><p>​    到现在为止，我学习三维图形的时间将近有一年了，经过这一年的学习，也算是入门了，对图形学也有一定的理解，同时也爱上了图形算法的研究。因为自己是GIS专业的，所以对于三维图形方面的研发相比计算机专业的起步较晚，所以这一年感觉挺吃力的，因为有太多的知识需要学习强化，我重点放在了C++和图形方面的学习，当然这些都是工作之外的业余时间。大概三个月前我决定在学习图形学的过程中可以把所学到的东西整理到一个框架之下，写一个自己的渲染器，就开始了不断重构之路，写了之后才知道，其实难点根本不是图形算法方面，而是怎么去设计，才能把书上的这些图形的东西都放到一起，然后又方便扩展和调用。可能单独写一个demo很快就可以写出来（毕竟网上例子很多），比如实现模型加载、光照、阴影等，但怎么把这些所有的功能都集成到一起，这可能就是需要架构的经验，但我根本没有这方便的经验，咋办？这时候开源引擎然后加上自己的理解，慢慢的就有了一些思路，每次设计一个功能模块时，先去看一下开源的引擎是如何设计，怎么调用的，最好能把好的设计移植过来，比如刚刚整理的这个版本就大量参考了一些开源的设计，后面会仔细讲一些模块移植过程以及自己的一些理解。</p>
<a id="more"></a>
<pre><code>TEST UPLOAD
TEST VIEW
</code></pre><p>​    其实在写的过程中我带着两个学习目的，其一当然是图形学的相关知识学习，其二就是渲染引擎或者C++工程方面框架设计的学习。所以写的时候我会假如自己在封装底层引擎功能，我如何设计才能让使用者更加容易理解，或者后期开发更加容易扩展和更新，且维护成本低，当然，由于缺乏经验，前期可能还是会以图形功能为主，然后尽量后面容易扩展和重构，尽量模仿开源引擎，因为扒开源代码也是一种很好的学习方式。所以这几个月大部分时间（都是工作之外的业余时间）都花在设计渲染器结构上，并没有实现出太多的图形功能，但我觉得在这个基础上，随着自己的深入研究，以后会有更多的功能集成上来。下面我就仔细介绍一下现有功能模块的一些设计。</p>
<h3 id="2-基础库的一些介绍"><a href="#2-基础库的一些介绍" class="headerlink" title="2.基础库的一些介绍"></a>2.基础库的一些介绍</h3><p>​    既然打算自己写渲染器，当然我希望大部分模型都能自己写，哪怕去移植别人的代码也好，尽量少引用第三方库，这样也可以学到更多的东西。就比方说Math库，可能没几个人回去自己实现或者抄一遍，但我觉得我在写的过程中也学到了挺多东西，虽然自己可能已经熟悉一些矩阵变换操作，但自己写一遍真不一样，比如Matrix类，以前我可能对矩阵左乘右乘，行矩阵列矩阵理解有些模糊，但写完这个之后基本对矩阵的一些操作了然于心了，还有四元数也理解根深一些（尽管还没完全理解），还包括视图矩阵、投影矩阵的推导等等，这是写Math库的一些感悟。还有Light、Camera、Shader、Texture这些基础的就不说了，这里还想提的一个就是关于相机控制器，因为我工作内容有段时间就是在实现一套Google Earth的鼠标操作，所以还是花了点时间在相机控制方面，主要就是围绕相机姿态、位置还有插值这些知识的理解，还有定点旋转、第一人称、第三人称漫游等等，我可能会单独更新一篇博客关于如何写好相机控制器，现在这个版本也有很多没有移植出来。只是写了一套如何发送消息然后调用不同的Transform方法。还有一些零碎的模块由于还没测试或者还没写完所以就先不说了，后续会再更新。我直接贴一段目前这个版本的调用逻辑吧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">Scene::<span class="function">ptr <span class="title">createScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Scene::ptr scene = <span class="built_in">std</span>::make_shared&lt;Scene&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//texture</span></span><br><span class="line">	Texture::ptr earthTex = TextureManager::Inst()-&gt;loadTexture(<span class="string">"earth"</span>, <span class="string">"../../../src/Data/texture/earthmap.jpg"</span>);</span><br><span class="line">	Texture::ptr boxTex = TextureManager::Inst()-&gt;loadTexture(<span class="string">"cloud"</span>, <span class="string">"../../../src/Data/texture/box.jpg"</span>);</span><br><span class="line">	Texture::ptr floorTex = TextureManager::Inst()-&gt;loadTexture(<span class="string">"earth"</span>, <span class="string">"../../../src/Data/texture/floor.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	TextureUnitState::ptr earthUnit = <span class="built_in">std</span>::make_shared&lt;TextureUnitState&gt;();</span><br><span class="line">	earthUnit-&gt;setTexture(earthTex);</span><br><span class="line">	TextureUnitState::ptr boxUnit = <span class="built_in">std</span>::make_shared&lt;TextureUnitState&gt;();</span><br><span class="line">	boxUnit-&gt;setTexture(boxTex);</span><br><span class="line">	TextureUnitState::ptr floorUnit = <span class="built_in">std</span>::make_shared&lt;TextureUnitState&gt;();</span><br><span class="line">	floorUnit-&gt;setTexture(floorTex);</span><br><span class="line">	<span class="comment">//material</span></span><br><span class="line">	Material::ptr floorMat = <span class="built_in">std</span>::make_shared&lt;Material&gt;();</span><br><span class="line">	floorMat-&gt;setMaterialType(Material::PhongMaterial);</span><br><span class="line">	floorMat-&gt;setMap(floorUnit);</span><br><span class="line">	floorMat-&gt;setCullFaceMode(CullFaceMode::DoubleSide);</span><br><span class="line"></span><br><span class="line">	Material::ptr earthMat = <span class="built_in">std</span>::make_shared&lt;Material&gt;();</span><br><span class="line">	earthMat-&gt;setMap(earthUnit);</span><br><span class="line">	earthMat-&gt;setMaterialType(Material::PhongMaterial);</span><br><span class="line"></span><br><span class="line">	Material::ptr boxMat = <span class="built_in">std</span>::make_shared&lt;Material&gt;();</span><br><span class="line">	boxMat-&gt;setMaterialType(Material::PhongMaterial);</span><br><span class="line">	boxMat-&gt;setMap(boxUnit);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//mesh</span></span><br><span class="line">	Mesh* <span class="built_in">floor</span> = GeometryFactory::MakeQuad(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">floor</span>-&gt;setMaterial(floorMat);</span><br><span class="line"></span><br><span class="line">	Mesh* box1 = GeometryFactory::MakeBox(<span class="number">20.0</span>, <span class="number">20.0</span>, <span class="number">20.0</span>);</span><br><span class="line">	box1-&gt;setPosition(Vector3D(<span class="number">-25.0</span>, <span class="number">10.0</span>, <span class="number">25.0</span>));	</span><br><span class="line">	box1-&gt;setMaterial(boxMat);</span><br><span class="line"></span><br><span class="line">	Mesh* box2 = GeometryFactory::MakeBox(<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>);</span><br><span class="line">	box2-&gt;setPosition(Vector3D(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">-25.0</span>));</span><br><span class="line">	box2-&gt;setMaterial(boxMat);</span><br><span class="line"></span><br><span class="line">	Mesh* box3 = GeometryFactory::MakeBox(<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>);</span><br><span class="line">	box3-&gt;setPosition(Vector3D(<span class="number">25.0</span>, <span class="number">5.0</span>, <span class="number">25.0</span>));</span><br><span class="line">	box3-&gt;setMaterial(boxMat);</span><br><span class="line"></span><br><span class="line">	Mesh* sphere = GeometryFactory::MakeSphere(<span class="number">8.0</span>, <span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line">	sphere-&gt;setPosition(Vector3D(<span class="number">0.0</span>, <span class="number">8.0</span>, <span class="number">0.0</span>));	</span><br><span class="line">	sphere-&gt;setMaterial(earthMat);</span><br><span class="line">	</span><br><span class="line">	Object::ptr root = <span class="built_in">std</span>::make_shared&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//light</span></span><br><span class="line">	DirectionLight* dlight = <span class="keyword">new</span> DirectionLight();</span><br><span class="line">	dlight-&gt;setPosition(Vector3D(<span class="number">0.0</span>, <span class="number">50.0</span>, <span class="number">50.0</span>));</span><br><span class="line">	dlight-&gt;setShadowCamera(<span class="keyword">new</span> OrthographicCamera(<span class="number">-50.0</span>, <span class="number">50.0</span>, <span class="number">-50.0</span>, <span class="number">50.0</span>, <span class="number">0.1</span>, <span class="number">100.0</span>));</span><br><span class="line"></span><br><span class="line">	PointLight* plight = <span class="keyword">new</span> PointLight();</span><br><span class="line">	plight-&gt;setPosition(Vector3D(<span class="number">0.0</span>, <span class="number">50.0</span>, <span class="number">0.0</span>));</span><br><span class="line">	plight-&gt;setShadowCamera(<span class="keyword">new</span> PerspectiveCamera(MathHelper::radian(<span class="number">70.0</span>), <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">200.0</span>));</span><br><span class="line"></span><br><span class="line">	SpotLight* spotlight = <span class="keyword">new</span> SpotLight;</span><br><span class="line">	spotlight-&gt;setPosition(Vector3D(<span class="number">0.0</span>, <span class="number">30.0</span>, <span class="number">0.0</span>));</span><br><span class="line">	spotlight-&gt;setAngle(M_PI/<span class="number">6.0</span>);</span><br><span class="line">	spotlight-&gt;setDecay(<span class="number">1.0</span>);</span><br><span class="line">	spotlight-&gt;setDistance(<span class="number">00.0</span>);</span><br><span class="line">	spotlight-&gt;setPenumbra(<span class="number">0.05</span>);</span><br><span class="line">	spotlight-&gt;setShadowCamera(<span class="keyword">new</span> PerspectiveCamera(MathHelper::radian(<span class="number">50.0</span>), <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">200.0</span>));</span><br><span class="line"></span><br><span class="line">	root-&gt;add(<span class="built_in">floor</span>);</span><br><span class="line">	root-&gt;add(box1);</span><br><span class="line">	root-&gt;add(box2);</span><br><span class="line">	root-&gt;add(box3);</span><br><span class="line">	root-&gt;add(sphere);</span><br><span class="line"></span><br><span class="line">	root-&gt;add(dlight);</span><br><span class="line">	root-&gt;add(plight);</span><br><span class="line">	root-&gt;add(spotlight);</span><br><span class="line">	scene-&gt;setSceneRoot(root);</span><br><span class="line">	scene-&gt;setUseShadowMap(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> scene;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Win::getSingleton()-&gt;create();	</span><br><span class="line">	PerspectiveCamera::ptr camera = make_shared&lt;PerspectiveCamera&gt;(MathHelper::radian(<span class="number">65.0</span>), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1</span>, <span class="number">500.0</span>);</span><br><span class="line">	camera-&gt;setPosition(Vector3D(<span class="number">0.0f</span>, <span class="number">50.0f</span>, <span class="number">-50.0</span>));</span><br><span class="line">	camera-&gt;lookAt(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">	Scene::ptr scene = createScene();</span><br><span class="line">	RenderSystem *rs = <span class="keyword">new</span> RenderSystem(scene.get(), camera.get());</span><br><span class="line">	Win::getSingleton()-&gt;loadRenderSystem(rs);</span><br><span class="line">	Win::getSingleton()-&gt;startRenderLoop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>​    这是一个简单的往Scene里面添加mesh和light，然后把scene和camera送到rendersystem开始渲染循环。</p>
<h3 id="3-开源移植模块介绍"><a href="#3-开源移植模块介绍" class="headerlink" title="3.开源移植模块介绍"></a>3.开源移植模块介绍</h3><p>​    其实如果熟悉一些开源引擎，比如OSG、OGRE就立马看出很多东西都是从上面移植过来，比如完全移植了OGRE的HardwareBuffer，因为一开始看到这个就很酷，就是居然可以利用GPU来管理顶点数据，同时也可以在CPU上读写数据，我记得以前顶点数据我都是直接用vector容器管理，简直了。其实移植的过程就是理解或者是学习的过程，并不多单纯的复制粘贴，毕竟你没看到是不可能完全移植的，所以还是费了一点时间去理解它那套逻辑。这套东西可以管理顶点、索引和纹理数据，比HardwareVertexBuffer设计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HardwareVertexBuffer</span> :</span> <span class="keyword">public</span> HardwareBuffer</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;HardwareVertexBuffer&gt; ptr;</span><br><span class="line">		HardwareVertexBuffer(<span class="keyword">size_t</span> vertex_size, <span class="keyword">size_t</span> num_vertices, HardwareBuffer::Usage usage, <span class="keyword">bool</span> use_shadow_buffer = <span class="literal">false</span>);</span><br><span class="line">		~HardwareVertexBuffer();</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>*	<span class="title">lock</span><span class="params">(<span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> length, LockOptions options)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>*	<span class="title">lock</span><span class="params">(LockOptions options)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>	<span class="title">unlock</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>	<span class="title">readData</span><span class="params">(<span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> length, <span class="keyword">void</span>* dest)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>	<span class="title">writeData</span><span class="params">(<span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> length, <span class="keyword">const</span> <span class="keyword">void</span>* source, <span class="keyword">bool</span> discardWholeBuffer = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//virtual void	copyData(HardwareBuffer&amp; src_buffer, size_t src_offset, size_t dst_offset, size_t length, bool discardWholeBuffer = false);</span></span><br><span class="line">		<span class="comment">//virtual void	copyData(HardwareBuffer&amp; src_buffer);</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> size_t	<span class="title">getSizeInBytes</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _sizeInBytes; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> Usage	<span class="title">getUsage</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _usage; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>    <span class="title">isLocked</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _isLocked; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>	<span class="title">isUseShadowBuffer</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _useShadowBuffer; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>    <span class="title">upload</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">		<span class="function">GLuint  <span class="title">getBufferID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _verexBufferID; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getVertexSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _vertexSize; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getVertexNum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _numVertices; &#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		GLuint _verexBufferID;<span class="comment">//vbo</span></span><br><span class="line">		<span class="keyword">size_t</span> _numVertices;<span class="comment">//</span></span><br><span class="line">		<span class="keyword">size_t</span> _vertexSize;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">size_t</span> _sizeInBytes;</span><br><span class="line">		Usage  _usage;</span><br><span class="line">		<span class="keyword">bool</span> _isLocked;</span><br><span class="line">		<span class="keyword">bool</span> _useShadowBuffer;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span>* _data;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​    它可以锁住一块内存，这块内存既可以是GPU也可以是CPU，然后进行读写数据，同时还可以设置shadowBuffer，是否在CPU端保存一份数据，比如在实际用的时候如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Mesh* mesh = <span class="keyword">new</span> Mesh;</span><br><span class="line"></span><br><span class="line">VertexData* vertexdata = <span class="keyword">new</span> VertexData;</span><br><span class="line">vertexdata-&gt;setVertexStart(<span class="number">0</span>);</span><br><span class="line">vertexdata-&gt;setVertexCount(<span class="number">4</span>);</span><br><span class="line">VertexDeclaration::ptr vd = vertexdata-&gt;getVertexDeclaration();</span><br><span class="line">VertexBufferBinding::ptr bind = vertexdata-&gt;getVertexBufferBinding();</span><br><span class="line"><span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">VertexElement::ptr tmp_ve = vd-&gt;addElement(<span class="number">0</span>, offset, VET_FLOAT3, VES_POSITION);</span><br><span class="line">offset += tmp_ve-&gt;getTypeSize(VET_FLOAT3);</span><br><span class="line">tmp_ve = vd-&gt;addElement(<span class="number">0</span>, offset, VET_FLOAT3, VES_NORMAL);</span><br><span class="line">offset += tmp_ve-&gt;getTypeSize(VET_FLOAT3);</span><br><span class="line">tmp_ve = vd-&gt;addElement(<span class="number">0</span>, offset, VET_FLOAT2, VES_TEXTURE_COORDINATES);</span><br><span class="line">offset += tmp_ve-&gt;getTypeSize(VET_FLOAT2);</span><br><span class="line"><span class="keyword">char</span>* data = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*vd-&gt;getVertexSize(<span class="number">0</span>) * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">float</span> halfWidth = width / <span class="number">2.0</span>, halfHeight = height / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">float</span> vertices[<span class="number">32</span>] = &#123;</span><br><span class="line">	-halfWidth, <span class="number">0.0</span>, halfHeight, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">	halfWidth, <span class="number">0.0</span>, halfHeight, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,</span><br><span class="line">	-halfWidth, <span class="number">0.0</span>, -halfHeight, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">	halfWidth, <span class="number">0.0</span>, -halfHeight, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HardwareVertexBuffer* buffer = <span class="keyword">new</span> HardwareVertexBuffer(offset, <span class="number">4</span>, HardwareBuffer::HBU_STATIC_WRITE_ONLY);</span><br><span class="line">bind-&gt;setBinding(<span class="number">0</span>, (HardwareVertexBuffer::ptr)buffer);</span><br><span class="line">buffer-&gt;writeData(<span class="number">0</span>, buffer-&gt;getSizeInBytes(), vertices);</span><br><span class="line"></span><br><span class="line">IndexData* indexdata = <span class="keyword">new</span> IndexData;</span><br><span class="line">indexdata-&gt;setIndexStart(<span class="number">0</span>);</span><br><span class="line">indexdata-&gt;setIndexCount(<span class="number">6</span>);</span><br><span class="line">HardwareIndexBuffer * index_buffer = <span class="keyword">new</span> HardwareIndexBuffer(HardwareIndexBuffer::IT_16BIT, <span class="number">6</span>, HardwareBuffer::HBU_STATIC_WRITE_ONLY);</span><br><span class="line">indexdata-&gt;setHardwareIndexBuffer((HardwareIndexBuffer::ptr)index_buffer);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> faces[<span class="number">36</span>] = &#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">index_buffer-&gt;writeData(<span class="number">0</span>, index_buffer-&gt;getSizeInBytes(), faces);</span><br><span class="line">mesh-&gt;setVertexData((VertexData::ptr)vertexdata);</span><br><span class="line">mesh-&gt;setIndexData((IndexData::ptr)indexdata);</span><br><span class="line"><span class="keyword">return</span> mesh;</span><br></pre></td></tr></table></figure>
<p>​    可能这里与OGRE不同的地方是，我只是设置了一个简单的内存池去分割内存，OGRE的内存池管理不一样，具体看代码。</p>
<p>​    第二个借鉴的开源引擎就是工作中项目在用Threejs，它是WebGL版的开源库，当然它本身也有很多是借鉴OGRE的。我觉得Threejs之所以这么多人用就是它设计的非常好用，经常看到对图形学一点都不懂的在用Threejs，所以我就像我写的OpenGL版本能不能也这样设计，所以我借鉴了两个非常重要的设计，其一是它所有的对象都继承自Object3D，并且可以以节点的形式挂接，于是我设计了同样的类Object。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mesh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span>;</span>	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sprite</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BillboardCollection</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleSystem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RayCaster</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerrianTile</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; ptr;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Object::ptr&gt; Children;</span><br><span class="line">	Object() :_position(Vector3D(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)), _scale(Vector3D(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)) &#123;&#125;</span><br><span class="line">	Object(<span class="keyword">const</span> Vector3D&amp; pos) :_position(pos), _scale(Vector3D(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)) &#123;&#125;</span><br><span class="line">	Object(<span class="keyword">const</span> Vector3D&amp; pos, <span class="keyword">const</span> Quaternion&amp; quat) :_position(pos), _orientation(quat), _scale(Vector3D(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Mesh* <span class="title">asMesh</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> Mesh* <span class="title">asMesh</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Light* <span class="title">asLight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> Light* <span class="title">asLight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//virtual Plugin* asPlugin() &#123; return 0; &#125;</span></span><br><span class="line">	<span class="comment">//virtual const Plugin* asPlugin() const &#123; return 0; &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Sprite* <span class="title">asSprite</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> Sprite* <span class="title">asSprite</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> BillboardCollection* <span class="title">asBillboardCollection</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> BillboardCollection* <span class="title">asBillboardCollection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> ParticleSystem* <span class="title">asParticleSystem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> ParticleSystem* <span class="title">asParticleSystem</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TerrianTile* <span class="title">asTerrianTile</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> TerrianTile* <span class="title">asTerrianTile</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Object* <span class="title">asObject</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> Object* <span class="title">asObject</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">raycast</span><span class="params">(RayCaster* raycaster, Utils::AnyValue&amp; intersects)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:		</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Object* <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> Object* <span class="title">getParent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _parent; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Object* object)</span> </span>&#123; _parent = object; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> Vector3D&amp; <span class="title">getPosition</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _position; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">const</span> Vector3D&amp; pos)</span> </span>&#123; _position = pos; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> Vector3D&amp; <span class="title">getScale</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _scale; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">const</span> Vector3D&amp; scale)</span> </span>&#123; _scale = scale; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> Quaternion&amp; <span class="title">getOrientation</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _orientation; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setOrientation</span><span class="params">(<span class="keyword">const</span> Quaternion&amp; orientation)</span> </span>&#123; _orientation = orientation; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">applyMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4D&amp; matrix)</span></span>;</span><br><span class="line">	<span class="comment">//_orientation set</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setRotationFromAxisAngle</span><span class="params">(<span class="keyword">const</span> Vector3D&amp; axis, <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setRotationFromMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4D&amp; rotate)</span></span>;</span><br><span class="line">	<span class="comment">//_orientation change</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotateOnAxis</span><span class="params">(<span class="keyword">const</span> Vector3D&amp; axis, <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotateOnAxisFixedPosition</span><span class="params">(<span class="keyword">const</span> Vector3D&amp; axis, <span class="keyword">double</span> angle)</span></span>;<span class="comment">//special use</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotateOnX</span><span class="params">(<span class="keyword">double</span> angle)</span> </span>&#123; rotateOnAxis(Vector3D(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), angle); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotateOnY</span><span class="params">(<span class="keyword">double</span> angle)</span> </span>&#123; rotateOnAxis(Vector3D(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>), angle); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotateOnZ</span><span class="params">(<span class="keyword">double</span> angle)</span> </span>&#123; rotateOnAxis(Vector3D(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>), angle); &#125;</span><br><span class="line">	<span class="comment">//for position change</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">translateOnAxis</span><span class="params">(<span class="keyword">const</span> Vector3D&amp; axis, <span class="keyword">double</span> distance)</span></span>;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">translateOnX</span><span class="params">(<span class="keyword">double</span> distance)</span> </span>&#123; translateOnAxis(Vector3D(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), distance); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">translateOnY</span><span class="params">(<span class="keyword">double</span> distance)</span> </span>&#123; translateOnAxis(Vector3D(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>), distance); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">translateOnZ</span><span class="params">(<span class="keyword">double</span> distance)</span> </span>&#123; translateOnAxis(Vector3D(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>), distance); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Vector3D <span class="title">getDirection</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _orientation * Vector3D(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); &#125;</span><br><span class="line">	<span class="function">Vector3D <span class="title">getUp</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _orientation * Vector3D(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="function">Vector3D <span class="title">getRight</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _orientation * Vector3D(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//useful function</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">localToWorld</span><span class="params">(Vector3D&amp; <span class="built_in">vector</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">worldToLocal</span><span class="params">(Vector3D&amp; <span class="built_in">vector</span>)</span></span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(Object* object)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(Object* object)</span></span>;</span><br><span class="line">	Object::<span class="function">ptr <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>;	</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getChildCount</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _children.size(); &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Children getChildren() &#123; return _children; &#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateMatrixLocal</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateMatrixWorld</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function">Matrix4D <span class="title">getLocalMatrix</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Matrix4D <span class="title">getWorldMatrix</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Vector3D <span class="title">getWorldPosition</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Quaternion <span class="title">getWorldQuaternion</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Vector3D <span class="title">getWorldScale</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Object* _parent;</span><br><span class="line">	Vector3D _position;</span><br><span class="line">	Vector3D _scale;</span><br><span class="line">	Quaternion _orientation;		</span><br><span class="line">	Children _children;</span><br><span class="line">	Matrix4D _matrix_local;</span><br><span class="line">	Matrix4D _matrix_world;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​    所有的Actor（UE4里面叫做Actor），我觉得非常合适，都有这些通用的属性信息，并且同时有OSG节点的设计，可以很好的连接场景，渲染的时候从根节点开始更新数据（主要是更新矩阵信息），然后不同的类型对场景又有不同的作用。Scene只需要记录根节点信息即可，具体见代码。</p>
<p>​    其二移植的地方就是Material，Threejs的不同的Material可以组装成不同的shader，从而得到不同的效果，目前移植了BasicMaterial和PhongMaterial，一个没有光照，一个有光照。通过Material设置属性，然后再渲染的时候根据材质类型获取需要的属性信息给uniform赋值，感觉这样的设计很不错，同时也移植了Threejs的BRDF的光照模型，还没测试GGX的那套，只测试了简单的，感觉效果可以，关于物理光照，后期会整理一篇文章，因为最近也在看这个。对于Material的移植可能后期还会详细讲述，因为目前还没完全移植，比如PhongMaterial加了光照效果如下。</p>
<p><img src="http://ovi6hpv55.bkt.clouddn.com/Light_ShadowMap.png" alt="DirectionLight"></p>
<p><img src="http://ovi6hpv55.bkt.clouddn.com/spot.png" alt="SpotLight"></p>
<p>更多实际效果以及具体代码看Github。</p>
<p>​    这两块是大块的移植，当然还有其它一些小的地方，就不一而足了。其实本来想把OGRE的ResourceManager这套移植过来，后来好像没啃下来，主要是感觉对我目前的这个版本实用性不大，至多就是有个TextureManager或者ShaderManager，如果后期会有多个场景的概念，再移植它这种资源的加载卸载机制来管理不同场景的资源。</p>
<h3 id="4-最后"><a href="#4-最后" class="headerlink" title="4.最后"></a>4.最后</h3><p>​    说实话写的时候一直在问自己一个问题，这有意义吗？别人开源引擎都封装的很好，用好它就可以做出很炫的效果，而且时间成本很低。的确如此，这可能并不是最有效率的学习方式，但却是我最喜欢的学习方式。我希望自己能有一件自己感兴趣的事情，一直去坚持写，坚持研究下去，仅仅是因为喜欢，不去追求它的实际意义。而些SimpleRenderEngine可能就是这么一件事情，我喜欢写代码，喜欢做一些酷炫的图形效果，然后就有了这件事，这可能就是它的意义吧，就是因为喜欢。</p>
<p>​    最后希望志同道合之人加入QQ群（528379336）一起讨论，同时欢迎fork</p>
<p>Github地址：<a href="https://github.com/LukiYLS/SimpleRenderEngine" target="_blank" rel="noopener">https://github.com/LukiYLS/SimpleRenderEngine</a></p>
]]></content>
      
        <categories>
            
            <category> SimpleRenderEngine </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenGL </tag>
            
            <tag> OSG </tag>
            
            <tag> OGRE </tag>
            
            <tag> ThreeJS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从零开始写渲染引擎-开篇]]></title>
      <url>/2017/09/05/%EF%BC%88url%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E6%A0%87%E9%A2%98%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近 准备开始写一个自己的渲染引擎，主要有两个目的：一是为了系统的学习关于如何从底层开始写一个渲染引擎，二是为了以后方便给自己用；我会在博客和github上同步更新我的进度，博客的目的是为了把自己开发过程中的思路记录下来，同时也希望能找到志同道合之人一起学习进步，如果自己的经验能够给别人有点帮助那就最好不过了，同时所有的代码都会更新到github当中，如果有人能加入一起造轮子，那我会非常欢迎。<br><a id="more"></a></p>
<p>​    其实写之前也犹豫了很久，很多人可能会问，现在这么多开源的引擎，为什么不直接用呢，原因其实很简单，就像我之前讲过我对开源的理解，开源并不是说我们能用它做多少事情，而是我们能从开源当前学会多少东西。现在越来越少的人会去自己造轮子，都是直接用现成的东西，所以经常会遇到很多半桶水水平的人，这种人真多很烦，因为我是GIS专业的，而且也是在GIS公司，公司有些所谓的 老鸟，用过一些开源的引擎做了点东西，以为自己对图形学很熟悉了，可是经常连模板测试都一知半解的，然后还跟你争执，真是无语了，这让我更加意识到自己需要把基础打好，不能步其后尘。而造轮子是非常好的学习方法，很多东西真的需要自己动手去一个坑一个坑的跳，你才能对一些知识理解的更深入一点。就比方说学习编译原理最好的方法就是自己写个编译器。</p>
<p>​    我可能会先从OpenGL开始写起，后面会考虑慢慢更新WebGL版本，不过WebGL版本可能会倾向于数据可视化方面，因为这也是我想研究的一个方向，现在可能自己还需要学习一下，毕竟现在Web端也算是一个趋势了，不过两个版本如果用同一个架构的话，移植还是挺好的，所以，目前还是先把OpenGL版本写好吧！</p>
<h2 id="SimpleRenderEngine-V1-0框架设计"><a href="#SimpleRenderEngine-V1-0框架设计" class="headerlink" title="SimpleRenderEngine V1.0框架设计"></a>SimpleRenderEngine V1.0框架设计</h2><p>​    其实我写这篇博客的时候已经完成了一些基础的框架设计，主要是实现了一些基础类，比如Texture，Light，Camera，Entity，Scene，Mesh我等等。要说框架设计，好像没什么东西，就是先想一个简单的方法把它们串到一起，后面可能要慢慢重构吧，因为第一版本没考虑很高深的架构设计，但我写之前对自己引擎框架的要求就是，外部尽量简单，所以就需要里面能很好的连在一起，因为现在模块也比较少，所以把它们联系到一起很简单。先看下我这个引擎绘制一个cube外部代码大概向下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Win::Inst()-&gt;createWindow();	</span><br><span class="line"><span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">vertices.push_back(Vertex(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">vertices.push_back(Vertex(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">vertices.push_back(Vertex(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">vertices.push_back(Vertex(<span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices = &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">Mesh::ptr mesh = <span class="built_in">std</span>::make_shared&lt;Mesh&gt;();</span><br><span class="line">mesh-&gt;setVertices(vertices);</span><br><span class="line">mesh-&gt;setIndex(indices);	</span><br><span class="line">mesh-&gt;createBuffer();	</span><br><span class="line"></span><br><span class="line">Light::ptr light = <span class="built_in">std</span>::make_shared&lt;Light&gt;();</span><br><span class="line">light-&gt;setType(PointLight);</span><br><span class="line"></span><br><span class="line">TextureManager::Inst()-&gt;loadTexture(<span class="string">"../../../src/Data/texture/1.jpg"</span>, <span class="string">"texture1"</span>);</span><br><span class="line">TextureManager::Inst()-&gt;loadTexture(<span class="string">"../../../src/Data/texture/2.jpg"</span>, <span class="string">"texture2"</span>);</span><br><span class="line">TextureManager::Inst()-&gt;loadTexture(<span class="string">"../../../src/Data/texture/3.jpg"</span>, <span class="string">"texture3"</span>);</span><br><span class="line"></span><br><span class="line">Camera::ptr camera = <span class="built_in">std</span>::make_shared&lt;Camera&gt;(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>));</span><br><span class="line">camera-&gt;setPerspectiveFovLHMatrix(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">Shader::ptr shader = <span class="built_in">std</span>::make_shared&lt;Shader&gt;(<span class="string">"../../../src/Data/shader/basic.vs"</span>, <span class="string">"../../../src/Data/shader/basic.fs"</span>);	</span><br><span class="line">mesh-&gt;setProgram(shader);	</span><br><span class="line"></span><br><span class="line">mesh-&gt;addTexture(<span class="string">"texture3"</span>);</span><br><span class="line"></span><br><span class="line">Scene::Inst()-&gt;addEntity(<span class="string">"test"</span>, (Entity::ptr)mesh);</span><br><span class="line">Scene::Inst()-&gt;addLight(light);</span><br><span class="line">Win::Inst()-&gt;starup(camera);</span><br></pre></td></tr></table></figure>
<p>​    其实这个很简单，就是数据丢到mesh当中，纹理丢到textureManager中，然后建个camera，把mesh加到scene中，绘制，OK。具体内部怎么调用，大家可以到github把代码git下来看一下。</p>
<p>​    我可能不会在博客里将太多理论的东西，因为红宝书上都有，如果有个别不能理解的可以提问，可能后续会有些原理复杂一点的我会专门写篇博客去讲解，我会把思路，其实应该是框架性的东西，分享出来，当我写的过程中不知怎么办的时候，我也会写出来跟大家交流。我是个小白，所以也会有很多问题，希望能得到大牛的指点，也希望自己能坚持下去，只是因为喜欢。</p>
]]></content>
      
        <categories>
            
            <category> 从零开始写渲染引擎 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Earth开发原理-基于LRU-K实现瓦片数据析构算法]]></title>
      <url>/2017/09/02/%EF%BC%88url%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E6%A0%87%E9%A2%98%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>​    用户访问三维earth过程中，客户端会源源不断的向服务器请求数据，尤其是多用户并发的情况下，请求更加频繁，所以服务器通常会设置缓存容器，主要是DEM和DOM缓存池，数据从server中请求后，会在服务器同时保留一份。比如请求google 影像，服务器根据wtms服务地址以及用户请求的瓦片层级，然后利用HTTP协议将数据传输至服务器，这时候服务器就将数据进行备份，这样等下一次在请求同样的数据时，就可以直接从服务器中获取，这样可以提高用户访问效率。然而，随着用户访问的增加，服务器缓存压力必然也会加大，所以就需要及时析构一些数据，保证服务器缓存池不会爆。</p>
<a id="more"></a>
<h2 id="LRU和LRU-K算法概述"><a href="#LRU和LRU-K算法概述" class="headerlink" title="LRU和LRU-K算法概述"></a>LRU和LRU-K算法概述</h2><p>​    缓存淘汰算法包括LRU、LFU和FIFO，关于这三种算法的比较，可以看一这篇博客：</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3749259.html" target="_blank" rel="noopener">缓存算法（页面置换算法）-FIFO、LFU、LRU</a></p>
<p>​    这里只对LRU-K（LRU-K改进）算法作一个简单介绍，LRU或者LRU-K缓存析构算法是一种比较简单常用的缓存淘汰机制，LRU主要根据资源访问时间来淘汰数据，也就是说访问数据间隔越久，其淘汰顺序应该是月优先，所以在设计算法时，只需要设计一个队列来存储每个资源的访问时间，新访问的数据放到最前，这样就可以保证末尾的数据时间间隔最久，每次淘汰只需从末尾开始淘汰。</p>
<p><img src="http://ovi6hpv55.bkt.clouddn.com/LRU.png" alt="LRU"></p>
<p>​    而LRU-K，则是增加了一个访问次数变量，通过访问次数K来控制需要淘汰的数据，所以它需要多维护一个队列来记录访问次数，</p>
<p><img src="http://ovi6hpv55.bkt.clouddn.com/LRU-K.png" alt="LRU-K"></p>
<ol>
<li>数据第一次被访问，加入到访问历史列表；</li>
<li>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</li>
<li>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li>
<li>缓存数据队列中被再次访问后，重新排序；</li>
<li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</li>
</ol>
<h2 id="瓦片数据析构算法实现"><a href="#瓦片数据析构算法实现" class="headerlink" title="瓦片数据析构算法实现"></a>瓦片数据析构算法实现</h2><p>​    LRU-K淘汰机制可以很好的应用到瓦片数据的析构中，因为访问次数和时间两个权重可以通时考虑到用户访问的效率以及缓存池的压力，所以考虑将此方法应用到DEM和DOM缓冲析构当中，首先要考虑的是两个参数的确定，时间当然是指用户的访问某瓦片的时间，次数表示某瓦片被用户访问的次数，每个用户只会记录一次，这里需要对LRU-K作一个小小的改进，因为我们考虑析构的原则是：很久没被访问，且访问次数少的瓦片应该优先淘汰，所以需要把这两个权重都加入到用户访问记录中去。</p>
<p>​    综合考虑，析构算法主要思路是：当用户请求瓦片时，记录该瓦片的访问时间，并且增加瓦片访问次数（+1操作）。每次请求数据时，通过时间来更新访问次数，如果访问时间间隔大于给定的最大时间，则访问次数（-1操作）。通过+1和-1两个操作控制瓦片访问次数，当内存池容量超过一定阈值，需要执行析构时，从访问记录中取前K个访问次数较少的瓦片，释放其资源。    </p>
<p>​    LRU Node的设计如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lru_node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">lru_queue</span>;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		lru_node();</span><br><span class="line">		<span class="keyword">virtual</span> ~lru_node();</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Hit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time_now_)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_time</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">bind_queue</span><span class="params">(lru_queue* queue_)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">unbind_queue</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> _last_use_time;</span><br><span class="line">		lru_queue*	 _lru_queue;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">list</span>&lt;lru_node*&gt;::iterator _self;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>​    可以看出，这里只是设计了节点的访问时间，并且维护了一个队列，lru_queu的设计如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lru_queue</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">lru_node</span>;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> gw_shared_ptr&lt;lru_queue&gt; ptr;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		lru_queue(runtime* run_time_, terrian_dem_resource_manager* dem_manager_);</span><br><span class="line">		lru_queue(runtime* run_time_, terrian_dom_resource_manager* dom_manager_);		</span><br><span class="line">		~lru_queue();</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">move_top</span><span class="params">(lru_node* node_)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(lru_node* node_)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_time</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">lru_node* <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">get_queue_size</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> lost_time_)</span></span>;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">list</span>&lt;lru_node* &gt; _list_queue;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		gw::mutex::ptr     _queue_mutex;</span><br><span class="line">		<span class="comment">//union</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="keyword">enum</span> Type&#123;DEM,DOM&#125;_type;		</span><br><span class="line">		terrian_dem_resource_manager* _dem_manager;</span><br><span class="line">		terrian_dom_resource_manager* _dom_manager;</span><br><span class="line">		<span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>​    其中update函数就是通过时间来更新瓦片访问次数，就是从尾部遍历队列，如果访问时间与当前时间间隔大于lost_time，则只需-1操作。</p>
<p>​    +1操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_user_visit_record</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> userid, geocode gc)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		lru_tile* node = <span class="keyword">new</span> lru_tile();</span><br><span class="line">		node-&gt;_gc = gc;</span><br><span class="line">		<span class="comment">//dom_rm-&gt;_dom_list-&gt;move_top(node);</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> timt_now = get_tick_count();</span><br><span class="line">		node-&gt;Hit(timt_now);</span><br><span class="line">		_queue_service-&gt;move_top(node, userid);</span><br><span class="line"></span><br><span class="line">		_visit_record_mutex-&gt;lock();</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RECORD_TYPE&gt;::iterator it = _visit_record_vec.begin();</span><br><span class="line">		<span class="keyword">for</span> (; it != _visit_record_vec.end(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (it-&gt;first == gc)</span><br><span class="line">			&#123;</span><br><span class="line">				it-&gt;second++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (it == _visit_record_vec.end())</span><br><span class="line">		&#123;</span><br><span class="line">			RECORD_TYPE record = <span class="built_in">std</span>::make_pair(gc,<span class="number">1</span>);			</span><br><span class="line">			_visit_record_vec.push_back(record);</span><br><span class="line">		&#125;</span><br><span class="line">		_visit_record_mutex-&gt;unlock();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>与之对应的-1操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit_count_plus_one</span><span class="params">(geocode gc_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_visit_record_mutex-&gt;lock();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RECORD_TYPE&gt;::iterator it = _visit_record_vec.begin();</span><br><span class="line">	<span class="keyword">for</span> (; it != _visit_record_vec.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it-&gt;first == gc_)</span><br><span class="line">		&#123;</span><br><span class="line">			it-&gt;second--;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_visit_record_mutex-&gt;unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这个析构算法，虽然到现在并没有真正测试多用户并发情况下的效率，只是可以保证内存池能够稳定在阈值之内，可以到实际情况，还需要不断的优化和改进，因为数据加载效率也是非常重要的考量。</p>
]]></content>
      
        <categories>
            
            <category> Earth开发原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Earth开发原理-阴影体实现要素贴地]]></title>
      <url>/2017/08/26/%EF%BC%88url%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E6%A0%87%E9%A2%98%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="关于阴影实现方法概述"><a href="#关于阴影实现方法概述" class="headerlink" title="关于阴影实现方法概述"></a>关于阴影实现方法概述</h2><p>​    <strong>Shadow map:</strong> 阴影的实现技术，我以前实现过比较基础的shadow map，就是利用从光源出发得到的深度图，然后每一个像素去比较当前深度值与深度图中的得到的深度值，深度图其实保存的应该是光源到遮光板之间的距离，而与它比较的是像素到光源的距离，如果小于，则说明处于阴影之中。还有一些细节的改进，比如阴影交叉如何处理（与深度图的分辨率有关，如果多个像素用同一个比较，就会出现这种情况），还有锯齿如何处理等等。</p>
<a id="more"></a>
<p>具体可以看这篇教程：<a href="http://www.opengl-tutorial.org/cn/intermediate-tutorials/tutorial-16-shadow-mapping/" target="_blank" rel="noopener">Shadow map</a>。</p>
<p>​    <strong>Shadow volume:</strong> 上面这种方法会有两个问题：1.如果光源动态变化，则每一次shadow map都要更新，这样开销会很大；2.上述出现的交叉阴影和锯齿问题，都没有一种很好的方法完美解决。因此Franklin C. Crow在1977年 提出了一种新的方法：Shadow volume。不过这种方法好像对于多光源的情况下，也并无优势。所以现在主流的依然是shadow map方法，可以结合deferred lighting技术。不过因为今天的主题是要用到阴影体这种方法，所以下面线详细介绍一下这种方法。</p>
<h2 id="Shadow-volume实现方法"><a href="#Shadow-volume实现方法" class="headerlink" title="Shadow volume实现方法"></a>Shadow volume实现方法</h2><p>​    shadow volume主要用到的原理是模板测试和深度测试，通过这两个测试，把阴影部分的stencil buffer计算出来，然后render这部分就可得到阴影。</p>
<p>​    第一步：构建阴影体。对mesh每一条边沿着光源方向进行拉伸，顶点部分除了原始的n个顶点(x,y,z,1)外，拉伸后的顶点同样也有n个，拉伸的长度应是无限远，但我们只有将其顶点形式设置为（x,y,z,0），在shader里面转换后自然就是无穷远处。面主要包括顶面、底面和侧面，底面三角形索引结构其实和顶面是一样的，侧面就是每一个quad由两个三角形组成，这样就可以得到阴影体的vertex buffer。</p>
<p><img src="http://ovi6hpv55.bkt.clouddn.com/volume_contrust.jpg" alt="volume_contrust"></p>
<p>​    第二步：Render pass。</p>
<p>​    pass1：打开depth test，按正常方式渲染整个场景，得到depth map。</p>
<p>​    pass2：打开stencil test，关掉z writing和color buffer writing，渲染shadow volumes；设置stencil test always pass，对于front faces，若z test pass，则stencil value +1，若z test fail，则不更新stencil value；对于back faces，若z test pass，则stencil value -1。</p>
<p>​    pass3：pass2完成之后，stencil buffer中value不为0的像素就处于阴影区域，据此绘制阴影效果即可。</p>
<p><img src="http://ovi6hpv55.bkt.clouddn.com/render_pass.jpg" alt="render_pass"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pass1</span></span><br><span class="line">RenderVolumetoDepth();</span><br><span class="line"><span class="comment">//pass 2</span></span><br><span class="line">glDepthMask(GL_FALSE);</span><br><span class="line">glEnable(GL_DEPTH_CLAMP);</span><br><span class="line">glDisable(GL_CULL_FACE);</span><br><span class="line">glStencilFunc(GL_ALWAYS, <span class="number">0</span>, <span class="number">0xff</span>);    </span><br><span class="line">glStencilOpSeparate(GL_BACK, GL_KEEP, GL_INCR_WRAP, GL_KEEP);</span><br><span class="line">glStencilOpSeparate(GL_FRONT, GL_KEEP, GL_DECR_WRAP, GL_KEEP);</span><br><span class="line">RenderVolume();</span><br><span class="line"><span class="comment">//pass 3</span></span><br><span class="line">glStencilFunc(GL_EQUAL, <span class="number">0x0</span>, <span class="number">0xFF</span>);	</span><br><span class="line">glStencilOpSeparate(GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP);</span><br><span class="line">RenderVolume();</span><br><span class="line">glDisable(GL_STENCIL_TEST);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>​    这样就可以实现一个简单的阴影效果了，其中核心就是利用模板测试标记出阴影部分，当然还有一些细节，比如多光源的时候需要遍历每一个光源，想根深一步了解可以看《GPU Gems》<a href="http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch09.html" target="_blank" rel="noopener">Chapter 9. Efficient Shadow Volume Rendering</a>.</p>
<h2 id="利用阴影体实现贴地效果"><a href="#利用阴影体实现贴地效果" class="headerlink" title="利用阴影体实现贴地效果"></a>利用阴影体实现贴地效果</h2><p>​    前面简单的介绍了一下shadow volume的原理，下面要进入正题，要素贴地。这算是三维球中一个很基本的功能，因为这会涉及要标会，量测，矢量要素加载等等，所以这个问题也必须解决，才能有后续这些相关功能的实现。一开始对这个没什么概念，想了很多方法，第一反应到的就是纹理。在有DEM数据的情况下，面对高低起伏的地形，如何将要素随着地形起伏，感觉只有将其作为一张纹理贴地和瓦片数据一样贴到地形网格上，才能完美贴地，好像osgearth就是这样做的，所以就去研究投影纹理技术，投影纹理就不展开讲了，就类似虚拟一个投影仪，然后将纹理投影到物体表面。</p>
<p>​    阴影体这个方法是看了cesium的源码才知道原来贴地还可以这样，关于cesium后面应该还会有很多篇博客来讲其中的一些图形学知识，因为近期一直在研究它的源码，cesium算是web端的标杆了，类似pc端的oe，现在很多都在用它搞二次开发，比如超图。我们虽然没有直接用它，但是很多地方都在借鉴它的一些原理，其实我觉得这才是开源的意义，开源并不是让你可以直接用它进行二次开发，更主要的是你能够弄懂里面的一些原理，并为自己所用，这叫站在巨人的肩膀上。现在很多所谓的三维GIS创业公司，不过是做了点二次开发，包装了一个界面，就拿出来骗钱，非常可笑。不过也是，这几年政府的钱太好骗了，不过这样的没点技术积累的公司基本也存活不了多久。好了，不说废话了，开始装逼了。</p>
<p>​    前面说了阴影体怎么构建，那到了有DEM的情况下，又应该如何构建呢？比如说画一个Polygon，首先要做的就是拉伸，那拉伸又包括拉伸方向和拉伸高度，拉伸方向很简单就是顶点法线，拉伸高度应该与polygon所在地形高程与关，必须保持拉伸高度超过其范围之内的最大高程，所以拉伸高度就是高程的最大值。</p>
<p><img src="http://ovi6hpv55.bkt.clouddn.com/terrian_volume.jpg" alt="terrian_volume"></p>
<p>​    阴影体构建之后，又如何只绘制贴地部分呢，这就要用到前面说的模板测试和深度测试了，这里有会有三个pass，不过这三个pass与前面的有点区别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pass 1</span></span><br><span class="line">gl.colorMask(<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">gl.depthMask(<span class="literal">false</span>);</span><br><span class="line">gl.enable(gl.STENCIL_TEST);</span><br><span class="line">gl.disable(gl.DEPTH_TEST);</span><br><span class="line">gl.disable(gl.CULL_FACE);</span><br><span class="line">gl.stencilFuncSeparate(gl.FRONT,gl.ALWAYS,<span class="number">0</span>,~<span class="number">0</span>);</span><br><span class="line">gl.stencilFuncSeparate(gl.BACK,gl.ALWAYS,<span class="number">0</span>,~<span class="number">0</span>);</span><br><span class="line">gl.stencilOpSeparate(gl.BACK,gl.KEEP,gl.DECR,gl.INCR_WRAP); gl.stencilOpSeparate(gl.FRONT,gl.KEEP,gl.DECR,gl.DECR_WRAP);</span><br><span class="line">renderShadowVolume(camera);</span><br><span class="line"><span class="comment">//pass 2</span></span><br><span class="line">gl.enable(gl.DEPTH_TEST);</span><br><span class="line">gl.depthFunc(gl.LEQUAL);</span><br><span class="line">gl.stencilFuncSeparate(gl.FRONT,gl.ALWAYS,<span class="number">0</span>,~<span class="number">0</span>);</span><br><span class="line">gl.stencilFuncSeparate(gl.BACK,gl.ALWAYS,<span class="number">0</span>,~<span class="number">0</span>);           gl.stencilOpSeparate(gl.BACK,gl.KEEP,gl.KEEP,gl.INCR_WRAP);</span><br><span class="line">gl.stencilOpSeparate(gl.FRONT,gl.KEEP,gl.KEEP,gl.DECR_WRAP);</span><br><span class="line">renderShadowVolume(camera);</span><br><span class="line"><span class="comment">//pass 3</span></span><br><span class="line">gl.colorMask(<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">gl.enable(gl.STENCIL_TEST);</span><br><span class="line">gl.enable(gl.BLEND);</span><br><span class="line">gl.disable(gl.DEPTH_TEST);</span><br><span class="line">gl.stencilFunc(gl.NOTEQUAL,<span class="number">0</span>,~<span class="number">0</span>);</span><br><span class="line">gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);</span><br><span class="line">renderShadowVolume(camera);</span><br><span class="line"><span class="comment">//set back</span></span><br><span class="line">gl.depthMask(<span class="literal">true</span>);</span><br><span class="line">gl.disable(gl.STENCIL_TEST);           gl.enable(gl.CULL_FACE);           </span><br><span class="line">gl.enable(gl.DEPTH_TEST);</span><br></pre></td></tr></table></figure>
<p>​    pass 1：关闭颜色写入以及背面裁剪（因为是双面绘制，模板函数不一样），开启模板测试，关闭深度测试，正面模板值-1，背面模板值+1</p>
<p>​    pass 2：开启深度测试和模板测试，同样正面-1，背面加+1</p>
<p>​    pass 3：开启颜色写入，将模板值不为0的区域绘制出来，自然就是和地形相交的部分，就可以看到贴地效果。</p>
<p>​    这里有个很有意思的地方，就是只要pass 2和pass 3其实就可以标记出贴地部分，但如果你camera进入到阴影体区域，应该通过关闭深度测试来标记出把地形遮挡的区域，所以pass 1的目的其实是为了标记出进入阴影体内部的贴地区域，这两个标记需要分成两个pass，这样即使你进入阴影体内部也可以达到同样的效果。</p>
<p><img src="http://ovi6hpv55.bkt.clouddn.com/clamp_terrian.png" alt="clamp_terrian"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这算是我我开通博客站点后的第一篇博客，我就喜欢这种直接上干货的形式，毕竟这也是我想写博客的目的，积累和分享。同时也希望能保存博客的质量，只要是拿出来的，一定要有价值。这篇博客的分类是Earth开发原理，意味着以后我会陆续把我在开发三维earth过程中，一些有价值，有意思的技术分享出来，但我并不会直接把源码放出来，因为我分享的技术。也希望有看到的朋友多提建议，共同交流。</p>
<p>​    预告：下一篇可能会是google earth相机实现</p>
]]></content>
      
        <categories>
            
            <category> Earth开发原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 三维GIS </tag>
            
            <tag> 图形算法 </tag>
            
            <tag> WebGL </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
